// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.0
// source: node_plugin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

/** NullValue 表示空值 */
export enum NullValue {
  NULL_VALUE = 0,
  UNRECOGNIZED = -1,
}

export function nullValueFromJSON(object: any): NullValue {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return NullValue.NULL_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NullValue.UNRECOGNIZED;
  }
}

export function nullValueToJSON(object: NullValue): string {
  switch (object) {
    case NullValue.NULL_VALUE:
      return "NULL_VALUE";
    case NullValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** NodeCategory 节点类别 */
export enum NodeCategory {
  CATEGORY_UNSPECIFIED = 0,
  /** CATEGORY_TRIGGER - 触发器 */
  CATEGORY_TRIGGER = 1,
  /** CATEGORY_ACTION - 动作 */
  CATEGORY_ACTION = 2,
  /** CATEGORY_CONDITION - 条件判断 */
  CATEGORY_CONDITION = 3,
  /** CATEGORY_TRANSFORM - 数据转换 */
  CATEGORY_TRANSFORM = 4,
  /** CATEGORY_INTEGRATION - 集成（外部服务） */
  CATEGORY_INTEGRATION = 5,
  /** CATEGORY_UTILITY - 工具类 */
  CATEGORY_UTILITY = 6,
  /** CATEGORY_AI - AI 相关 */
  CATEGORY_AI = 7,
  /** CATEGORY_MEDIA - 媒体处理 */
  CATEGORY_MEDIA = 8,
  UNRECOGNIZED = -1,
}

export function nodeCategoryFromJSON(object: any): NodeCategory {
  switch (object) {
    case 0:
    case "CATEGORY_UNSPECIFIED":
      return NodeCategory.CATEGORY_UNSPECIFIED;
    case 1:
    case "CATEGORY_TRIGGER":
      return NodeCategory.CATEGORY_TRIGGER;
    case 2:
    case "CATEGORY_ACTION":
      return NodeCategory.CATEGORY_ACTION;
    case 3:
    case "CATEGORY_CONDITION":
      return NodeCategory.CATEGORY_CONDITION;
    case 4:
    case "CATEGORY_TRANSFORM":
      return NodeCategory.CATEGORY_TRANSFORM;
    case 5:
    case "CATEGORY_INTEGRATION":
      return NodeCategory.CATEGORY_INTEGRATION;
    case 6:
    case "CATEGORY_UTILITY":
      return NodeCategory.CATEGORY_UTILITY;
    case 7:
    case "CATEGORY_AI":
      return NodeCategory.CATEGORY_AI;
    case 8:
    case "CATEGORY_MEDIA":
      return NodeCategory.CATEGORY_MEDIA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeCategory.UNRECOGNIZED;
  }
}

export function nodeCategoryToJSON(object: NodeCategory): string {
  switch (object) {
    case NodeCategory.CATEGORY_UNSPECIFIED:
      return "CATEGORY_UNSPECIFIED";
    case NodeCategory.CATEGORY_TRIGGER:
      return "CATEGORY_TRIGGER";
    case NodeCategory.CATEGORY_ACTION:
      return "CATEGORY_ACTION";
    case NodeCategory.CATEGORY_CONDITION:
      return "CATEGORY_CONDITION";
    case NodeCategory.CATEGORY_TRANSFORM:
      return "CATEGORY_TRANSFORM";
    case NodeCategory.CATEGORY_INTEGRATION:
      return "CATEGORY_INTEGRATION";
    case NodeCategory.CATEGORY_UTILITY:
      return "CATEGORY_UTILITY";
    case NodeCategory.CATEGORY_AI:
      return "CATEGORY_AI";
    case NodeCategory.CATEGORY_MEDIA:
      return "CATEGORY_MEDIA";
    case NodeCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** NodeType 节点类型 */
export enum NodeType {
  NODE_TYPE_UNSPECIFIED = 0,
  /** NODE_TYPE_TRIGGER - 触发器（工作流入口） */
  NODE_TYPE_TRIGGER = 1,
  /** NODE_TYPE_PROCESSOR - 处理器（普通节点） */
  NODE_TYPE_PROCESSOR = 2,
  /** NODE_TYPE_BRANCH - 分支节点 */
  NODE_TYPE_BRANCH = 3,
  /** NODE_TYPE_MERGE - 合并节点 */
  NODE_TYPE_MERGE = 4,
  /** NODE_TYPE_SUBFLOW - 子工作流 */
  NODE_TYPE_SUBFLOW = 5,
  UNRECOGNIZED = -1,
}

export function nodeTypeFromJSON(object: any): NodeType {
  switch (object) {
    case 0:
    case "NODE_TYPE_UNSPECIFIED":
      return NodeType.NODE_TYPE_UNSPECIFIED;
    case 1:
    case "NODE_TYPE_TRIGGER":
      return NodeType.NODE_TYPE_TRIGGER;
    case 2:
    case "NODE_TYPE_PROCESSOR":
      return NodeType.NODE_TYPE_PROCESSOR;
    case 3:
    case "NODE_TYPE_BRANCH":
      return NodeType.NODE_TYPE_BRANCH;
    case 4:
    case "NODE_TYPE_MERGE":
      return NodeType.NODE_TYPE_MERGE;
    case 5:
    case "NODE_TYPE_SUBFLOW":
      return NodeType.NODE_TYPE_SUBFLOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType.UNRECOGNIZED;
  }
}

export function nodeTypeToJSON(object: NodeType): string {
  switch (object) {
    case NodeType.NODE_TYPE_UNSPECIFIED:
      return "NODE_TYPE_UNSPECIFIED";
    case NodeType.NODE_TYPE_TRIGGER:
      return "NODE_TYPE_TRIGGER";
    case NodeType.NODE_TYPE_PROCESSOR:
      return "NODE_TYPE_PROCESSOR";
    case NodeType.NODE_TYPE_BRANCH:
      return "NODE_TYPE_BRANCH";
    case NodeType.NODE_TYPE_MERGE:
      return "NODE_TYPE_MERGE";
    case NodeType.NODE_TYPE_SUBFLOW:
      return "NODE_TYPE_SUBFLOW";
    case NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ParameterType 参数类型 */
export enum ParameterType {
  PARAM_TYPE_UNSPECIFIED = 0,
  PARAM_TYPE_STRING = 1,
  PARAM_TYPE_INT = 2,
  PARAM_TYPE_FLOAT = 3,
  PARAM_TYPE_BOOL = 4,
  PARAM_TYPE_BYTES = 5,
  PARAM_TYPE_ARRAY = 6,
  PARAM_TYPE_OBJECT = 7,
  /** PARAM_TYPE_ENUM - 枚举类型 */
  PARAM_TYPE_ENUM = 8,
  /** PARAM_TYPE_SECRET - 敏感信息（密码等） */
  PARAM_TYPE_SECRET = 9,
  /** PARAM_TYPE_EXPRESSION - 表达式（支持变量引用） */
  PARAM_TYPE_EXPRESSION = 10,
  /** PARAM_TYPE_CODE - 代码片段 */
  PARAM_TYPE_CODE = 11,
  /** PARAM_TYPE_JSON - JSON 数据 */
  PARAM_TYPE_JSON = 12,
  /** PARAM_TYPE_FILE - 文件 */
  PARAM_TYPE_FILE = 13,
  /** PARAM_TYPE_URL - URL */
  PARAM_TYPE_URL = 14,
  /** PARAM_TYPE_DATETIME - 日期时间 */
  PARAM_TYPE_DATETIME = 15,
  UNRECOGNIZED = -1,
}

export function parameterTypeFromJSON(object: any): ParameterType {
  switch (object) {
    case 0:
    case "PARAM_TYPE_UNSPECIFIED":
      return ParameterType.PARAM_TYPE_UNSPECIFIED;
    case 1:
    case "PARAM_TYPE_STRING":
      return ParameterType.PARAM_TYPE_STRING;
    case 2:
    case "PARAM_TYPE_INT":
      return ParameterType.PARAM_TYPE_INT;
    case 3:
    case "PARAM_TYPE_FLOAT":
      return ParameterType.PARAM_TYPE_FLOAT;
    case 4:
    case "PARAM_TYPE_BOOL":
      return ParameterType.PARAM_TYPE_BOOL;
    case 5:
    case "PARAM_TYPE_BYTES":
      return ParameterType.PARAM_TYPE_BYTES;
    case 6:
    case "PARAM_TYPE_ARRAY":
      return ParameterType.PARAM_TYPE_ARRAY;
    case 7:
    case "PARAM_TYPE_OBJECT":
      return ParameterType.PARAM_TYPE_OBJECT;
    case 8:
    case "PARAM_TYPE_ENUM":
      return ParameterType.PARAM_TYPE_ENUM;
    case 9:
    case "PARAM_TYPE_SECRET":
      return ParameterType.PARAM_TYPE_SECRET;
    case 10:
    case "PARAM_TYPE_EXPRESSION":
      return ParameterType.PARAM_TYPE_EXPRESSION;
    case 11:
    case "PARAM_TYPE_CODE":
      return ParameterType.PARAM_TYPE_CODE;
    case 12:
    case "PARAM_TYPE_JSON":
      return ParameterType.PARAM_TYPE_JSON;
    case 13:
    case "PARAM_TYPE_FILE":
      return ParameterType.PARAM_TYPE_FILE;
    case 14:
    case "PARAM_TYPE_URL":
      return ParameterType.PARAM_TYPE_URL;
    case 15:
    case "PARAM_TYPE_DATETIME":
      return ParameterType.PARAM_TYPE_DATETIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParameterType.UNRECOGNIZED;
  }
}

export function parameterTypeToJSON(object: ParameterType): string {
  switch (object) {
    case ParameterType.PARAM_TYPE_UNSPECIFIED:
      return "PARAM_TYPE_UNSPECIFIED";
    case ParameterType.PARAM_TYPE_STRING:
      return "PARAM_TYPE_STRING";
    case ParameterType.PARAM_TYPE_INT:
      return "PARAM_TYPE_INT";
    case ParameterType.PARAM_TYPE_FLOAT:
      return "PARAM_TYPE_FLOAT";
    case ParameterType.PARAM_TYPE_BOOL:
      return "PARAM_TYPE_BOOL";
    case ParameterType.PARAM_TYPE_BYTES:
      return "PARAM_TYPE_BYTES";
    case ParameterType.PARAM_TYPE_ARRAY:
      return "PARAM_TYPE_ARRAY";
    case ParameterType.PARAM_TYPE_OBJECT:
      return "PARAM_TYPE_OBJECT";
    case ParameterType.PARAM_TYPE_ENUM:
      return "PARAM_TYPE_ENUM";
    case ParameterType.PARAM_TYPE_SECRET:
      return "PARAM_TYPE_SECRET";
    case ParameterType.PARAM_TYPE_EXPRESSION:
      return "PARAM_TYPE_EXPRESSION";
    case ParameterType.PARAM_TYPE_CODE:
      return "PARAM_TYPE_CODE";
    case ParameterType.PARAM_TYPE_JSON:
      return "PARAM_TYPE_JSON";
    case ParameterType.PARAM_TYPE_FILE:
      return "PARAM_TYPE_FILE";
    case ParameterType.PARAM_TYPE_URL:
      return "PARAM_TYPE_URL";
    case ParameterType.PARAM_TYPE_DATETIME:
      return "PARAM_TYPE_DATETIME";
    case ParameterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ParameterUIType UI 展示类型 */
export enum ParameterUIType {
  UI_TYPE_UNSPECIFIED = 0,
  /** UI_TYPE_TEXT - 单行文本 */
  UI_TYPE_TEXT = 1,
  /** UI_TYPE_TEXTAREA - 多行文本 */
  UI_TYPE_TEXTAREA = 2,
  /** UI_TYPE_NUMBER - 数字输入 */
  UI_TYPE_NUMBER = 3,
  /** UI_TYPE_SWITCH - 开关 */
  UI_TYPE_SWITCH = 4,
  /** UI_TYPE_SELECT - 下拉选择 */
  UI_TYPE_SELECT = 5,
  /** UI_TYPE_MULTI_SELECT - 多选 */
  UI_TYPE_MULTI_SELECT = 6,
  /** UI_TYPE_RADIO - 单选按钮组 */
  UI_TYPE_RADIO = 7,
  /** UI_TYPE_CHECKBOX - 复选框 */
  UI_TYPE_CHECKBOX = 8,
  /** UI_TYPE_DATE - 日期选择 */
  UI_TYPE_DATE = 9,
  /** UI_TYPE_TIME - 时间选择 */
  UI_TYPE_TIME = 10,
  /** UI_TYPE_DATETIME - 日期时间选择 */
  UI_TYPE_DATETIME = 11,
  /** UI_TYPE_COLOR - 颜色选择 */
  UI_TYPE_COLOR = 12,
  /** UI_TYPE_FILE - 文件上传 */
  UI_TYPE_FILE = 13,
  /** UI_TYPE_CODE_EDITOR - 代码编辑器 */
  UI_TYPE_CODE_EDITOR = 14,
  /** UI_TYPE_JSON_EDITOR - JSON 编辑器 */
  UI_TYPE_JSON_EDITOR = 15,
  /** UI_TYPE_EXPRESSION - 表达式编辑器 */
  UI_TYPE_EXPRESSION = 16,
  /** UI_TYPE_KEY_VALUE - 键值对编辑器 */
  UI_TYPE_KEY_VALUE = 17,
  /** UI_TYPE_SLIDER - 滑动条 */
  UI_TYPE_SLIDER = 18,
  UNRECOGNIZED = -1,
}

export function parameterUITypeFromJSON(object: any): ParameterUIType {
  switch (object) {
    case 0:
    case "UI_TYPE_UNSPECIFIED":
      return ParameterUIType.UI_TYPE_UNSPECIFIED;
    case 1:
    case "UI_TYPE_TEXT":
      return ParameterUIType.UI_TYPE_TEXT;
    case 2:
    case "UI_TYPE_TEXTAREA":
      return ParameterUIType.UI_TYPE_TEXTAREA;
    case 3:
    case "UI_TYPE_NUMBER":
      return ParameterUIType.UI_TYPE_NUMBER;
    case 4:
    case "UI_TYPE_SWITCH":
      return ParameterUIType.UI_TYPE_SWITCH;
    case 5:
    case "UI_TYPE_SELECT":
      return ParameterUIType.UI_TYPE_SELECT;
    case 6:
    case "UI_TYPE_MULTI_SELECT":
      return ParameterUIType.UI_TYPE_MULTI_SELECT;
    case 7:
    case "UI_TYPE_RADIO":
      return ParameterUIType.UI_TYPE_RADIO;
    case 8:
    case "UI_TYPE_CHECKBOX":
      return ParameterUIType.UI_TYPE_CHECKBOX;
    case 9:
    case "UI_TYPE_DATE":
      return ParameterUIType.UI_TYPE_DATE;
    case 10:
    case "UI_TYPE_TIME":
      return ParameterUIType.UI_TYPE_TIME;
    case 11:
    case "UI_TYPE_DATETIME":
      return ParameterUIType.UI_TYPE_DATETIME;
    case 12:
    case "UI_TYPE_COLOR":
      return ParameterUIType.UI_TYPE_COLOR;
    case 13:
    case "UI_TYPE_FILE":
      return ParameterUIType.UI_TYPE_FILE;
    case 14:
    case "UI_TYPE_CODE_EDITOR":
      return ParameterUIType.UI_TYPE_CODE_EDITOR;
    case 15:
    case "UI_TYPE_JSON_EDITOR":
      return ParameterUIType.UI_TYPE_JSON_EDITOR;
    case 16:
    case "UI_TYPE_EXPRESSION":
      return ParameterUIType.UI_TYPE_EXPRESSION;
    case 17:
    case "UI_TYPE_KEY_VALUE":
      return ParameterUIType.UI_TYPE_KEY_VALUE;
    case 18:
    case "UI_TYPE_SLIDER":
      return ParameterUIType.UI_TYPE_SLIDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParameterUIType.UNRECOGNIZED;
  }
}

export function parameterUITypeToJSON(object: ParameterUIType): string {
  switch (object) {
    case ParameterUIType.UI_TYPE_UNSPECIFIED:
      return "UI_TYPE_UNSPECIFIED";
    case ParameterUIType.UI_TYPE_TEXT:
      return "UI_TYPE_TEXT";
    case ParameterUIType.UI_TYPE_TEXTAREA:
      return "UI_TYPE_TEXTAREA";
    case ParameterUIType.UI_TYPE_NUMBER:
      return "UI_TYPE_NUMBER";
    case ParameterUIType.UI_TYPE_SWITCH:
      return "UI_TYPE_SWITCH";
    case ParameterUIType.UI_TYPE_SELECT:
      return "UI_TYPE_SELECT";
    case ParameterUIType.UI_TYPE_MULTI_SELECT:
      return "UI_TYPE_MULTI_SELECT";
    case ParameterUIType.UI_TYPE_RADIO:
      return "UI_TYPE_RADIO";
    case ParameterUIType.UI_TYPE_CHECKBOX:
      return "UI_TYPE_CHECKBOX";
    case ParameterUIType.UI_TYPE_DATE:
      return "UI_TYPE_DATE";
    case ParameterUIType.UI_TYPE_TIME:
      return "UI_TYPE_TIME";
    case ParameterUIType.UI_TYPE_DATETIME:
      return "UI_TYPE_DATETIME";
    case ParameterUIType.UI_TYPE_COLOR:
      return "UI_TYPE_COLOR";
    case ParameterUIType.UI_TYPE_FILE:
      return "UI_TYPE_FILE";
    case ParameterUIType.UI_TYPE_CODE_EDITOR:
      return "UI_TYPE_CODE_EDITOR";
    case ParameterUIType.UI_TYPE_JSON_EDITOR:
      return "UI_TYPE_JSON_EDITOR";
    case ParameterUIType.UI_TYPE_EXPRESSION:
      return "UI_TYPE_EXPRESSION";
    case ParameterUIType.UI_TYPE_KEY_VALUE:
      return "UI_TYPE_KEY_VALUE";
    case ParameterUIType.UI_TYPE_SLIDER:
      return "UI_TYPE_SLIDER";
    case ParameterUIType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ResponseType 响应类型 */
export enum ResponseType {
  RESPONSE_TYPE_UNSPECIFIED = 0,
  /** RESPONSE_TYPE_LOG - 日志 */
  RESPONSE_TYPE_LOG = 1,
  /** RESPONSE_TYPE_PROGRESS - 进度 */
  RESPONSE_TYPE_PROGRESS = 2,
  /** RESPONSE_TYPE_RESULT - 结果 */
  RESPONSE_TYPE_RESULT = 3,
  /** RESPONSE_TYPE_ERROR - 错误 */
  RESPONSE_TYPE_ERROR = 4,
  UNRECOGNIZED = -1,
}

export function responseTypeFromJSON(object: any): ResponseType {
  switch (object) {
    case 0:
    case "RESPONSE_TYPE_UNSPECIFIED":
      return ResponseType.RESPONSE_TYPE_UNSPECIFIED;
    case 1:
    case "RESPONSE_TYPE_LOG":
      return ResponseType.RESPONSE_TYPE_LOG;
    case 2:
    case "RESPONSE_TYPE_PROGRESS":
      return ResponseType.RESPONSE_TYPE_PROGRESS;
    case 3:
    case "RESPONSE_TYPE_RESULT":
      return ResponseType.RESPONSE_TYPE_RESULT;
    case 4:
    case "RESPONSE_TYPE_ERROR":
      return ResponseType.RESPONSE_TYPE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResponseType.UNRECOGNIZED;
  }
}

export function responseTypeToJSON(object: ResponseType): string {
  switch (object) {
    case ResponseType.RESPONSE_TYPE_UNSPECIFIED:
      return "RESPONSE_TYPE_UNSPECIFIED";
    case ResponseType.RESPONSE_TYPE_LOG:
      return "RESPONSE_TYPE_LOG";
    case ResponseType.RESPONSE_TYPE_PROGRESS:
      return "RESPONSE_TYPE_PROGRESS";
    case ResponseType.RESPONSE_TYPE_RESULT:
      return "RESPONSE_TYPE_RESULT";
    case ResponseType.RESPONSE_TYPE_ERROR:
      return "RESPONSE_TYPE_ERROR";
    case ResponseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LogLevel 日志级别 */
export enum LogLevel {
  LOG_LEVEL_UNSPECIFIED = 0,
  LOG_LEVEL_TRACE = 1,
  LOG_LEVEL_DEBUG = 2,
  LOG_LEVEL_INFO = 3,
  LOG_LEVEL_WARN = 4,
  LOG_LEVEL_ERROR = 5,
  UNRECOGNIZED = -1,
}

export function logLevelFromJSON(object: any): LogLevel {
  switch (object) {
    case 0:
    case "LOG_LEVEL_UNSPECIFIED":
      return LogLevel.LOG_LEVEL_UNSPECIFIED;
    case 1:
    case "LOG_LEVEL_TRACE":
      return LogLevel.LOG_LEVEL_TRACE;
    case 2:
    case "LOG_LEVEL_DEBUG":
      return LogLevel.LOG_LEVEL_DEBUG;
    case 3:
    case "LOG_LEVEL_INFO":
      return LogLevel.LOG_LEVEL_INFO;
    case 4:
    case "LOG_LEVEL_WARN":
      return LogLevel.LOG_LEVEL_WARN;
    case 5:
    case "LOG_LEVEL_ERROR":
      return LogLevel.LOG_LEVEL_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogLevel.UNRECOGNIZED;
  }
}

export function logLevelToJSON(object: LogLevel): string {
  switch (object) {
    case LogLevel.LOG_LEVEL_UNSPECIFIED:
      return "LOG_LEVEL_UNSPECIFIED";
    case LogLevel.LOG_LEVEL_TRACE:
      return "LOG_LEVEL_TRACE";
    case LogLevel.LOG_LEVEL_DEBUG:
      return "LOG_LEVEL_DEBUG";
    case LogLevel.LOG_LEVEL_INFO:
      return "LOG_LEVEL_INFO";
    case LogLevel.LOG_LEVEL_WARN:
      return "LOG_LEVEL_WARN";
    case LogLevel.LOG_LEVEL_ERROR:
      return "LOG_LEVEL_ERROR";
    case LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ExecutionStatus 执行状态 */
export enum ExecutionStatus {
  EXECUTION_STATUS_UNSPECIFIED = 0,
  /** EXECUTION_STATUS_SUCCESS - 成功 */
  EXECUTION_STATUS_SUCCESS = 1,
  /** EXECUTION_STATUS_SKIPPED - 跳过 */
  EXECUTION_STATUS_SKIPPED = 2,
  /** EXECUTION_STATUS_PARTIAL - 部分成功 */
  EXECUTION_STATUS_PARTIAL = 3,
  UNRECOGNIZED = -1,
}

export function executionStatusFromJSON(object: any): ExecutionStatus {
  switch (object) {
    case 0:
    case "EXECUTION_STATUS_UNSPECIFIED":
      return ExecutionStatus.EXECUTION_STATUS_UNSPECIFIED;
    case 1:
    case "EXECUTION_STATUS_SUCCESS":
      return ExecutionStatus.EXECUTION_STATUS_SUCCESS;
    case 2:
    case "EXECUTION_STATUS_SKIPPED":
      return ExecutionStatus.EXECUTION_STATUS_SKIPPED;
    case 3:
    case "EXECUTION_STATUS_PARTIAL":
      return ExecutionStatus.EXECUTION_STATUS_PARTIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionStatus.UNRECOGNIZED;
  }
}

export function executionStatusToJSON(object: ExecutionStatus): string {
  switch (object) {
    case ExecutionStatus.EXECUTION_STATUS_UNSPECIFIED:
      return "EXECUTION_STATUS_UNSPECIFIED";
    case ExecutionStatus.EXECUTION_STATUS_SUCCESS:
      return "EXECUTION_STATUS_SUCCESS";
    case ExecutionStatus.EXECUTION_STATUS_SKIPPED:
      return "EXECUTION_STATUS_SKIPPED";
    case ExecutionStatus.EXECUTION_STATUS_PARTIAL:
      return "EXECUTION_STATUS_PARTIAL";
    case ExecutionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ErrorType 错误类型 */
export enum ErrorType {
  ERROR_TYPE_UNSPECIFIED = 0,
  /** ERROR_TYPE_VALIDATION - 参数验证错误 */
  ERROR_TYPE_VALIDATION = 1,
  /** ERROR_TYPE_AUTHENTICATION - 认证错误 */
  ERROR_TYPE_AUTHENTICATION = 2,
  /** ERROR_TYPE_AUTHORIZATION - 授权错误 */
  ERROR_TYPE_AUTHORIZATION = 3,
  /** ERROR_TYPE_NOT_FOUND - 资源不存在 */
  ERROR_TYPE_NOT_FOUND = 4,
  /** ERROR_TYPE_RATE_LIMIT - 速率限制 */
  ERROR_TYPE_RATE_LIMIT = 5,
  /** ERROR_TYPE_TIMEOUT - 超时 */
  ERROR_TYPE_TIMEOUT = 6,
  /** ERROR_TYPE_NETWORK - 网络错误 */
  ERROR_TYPE_NETWORK = 7,
  /** ERROR_TYPE_INTERNAL - 内部错误 */
  ERROR_TYPE_INTERNAL = 8,
  /** ERROR_TYPE_EXTERNAL - 外部服务错误 */
  ERROR_TYPE_EXTERNAL = 9,
  /** ERROR_TYPE_CANCELLED - 已取消 */
  ERROR_TYPE_CANCELLED = 10,
  UNRECOGNIZED = -1,
}

export function errorTypeFromJSON(object: any): ErrorType {
  switch (object) {
    case 0:
    case "ERROR_TYPE_UNSPECIFIED":
      return ErrorType.ERROR_TYPE_UNSPECIFIED;
    case 1:
    case "ERROR_TYPE_VALIDATION":
      return ErrorType.ERROR_TYPE_VALIDATION;
    case 2:
    case "ERROR_TYPE_AUTHENTICATION":
      return ErrorType.ERROR_TYPE_AUTHENTICATION;
    case 3:
    case "ERROR_TYPE_AUTHORIZATION":
      return ErrorType.ERROR_TYPE_AUTHORIZATION;
    case 4:
    case "ERROR_TYPE_NOT_FOUND":
      return ErrorType.ERROR_TYPE_NOT_FOUND;
    case 5:
    case "ERROR_TYPE_RATE_LIMIT":
      return ErrorType.ERROR_TYPE_RATE_LIMIT;
    case 6:
    case "ERROR_TYPE_TIMEOUT":
      return ErrorType.ERROR_TYPE_TIMEOUT;
    case 7:
    case "ERROR_TYPE_NETWORK":
      return ErrorType.ERROR_TYPE_NETWORK;
    case 8:
    case "ERROR_TYPE_INTERNAL":
      return ErrorType.ERROR_TYPE_INTERNAL;
    case 9:
    case "ERROR_TYPE_EXTERNAL":
      return ErrorType.ERROR_TYPE_EXTERNAL;
    case 10:
    case "ERROR_TYPE_CANCELLED":
      return ErrorType.ERROR_TYPE_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorType.UNRECOGNIZED;
  }
}

export function errorTypeToJSON(object: ErrorType): string {
  switch (object) {
    case ErrorType.ERROR_TYPE_UNSPECIFIED:
      return "ERROR_TYPE_UNSPECIFIED";
    case ErrorType.ERROR_TYPE_VALIDATION:
      return "ERROR_TYPE_VALIDATION";
    case ErrorType.ERROR_TYPE_AUTHENTICATION:
      return "ERROR_TYPE_AUTHENTICATION";
    case ErrorType.ERROR_TYPE_AUTHORIZATION:
      return "ERROR_TYPE_AUTHORIZATION";
    case ErrorType.ERROR_TYPE_NOT_FOUND:
      return "ERROR_TYPE_NOT_FOUND";
    case ErrorType.ERROR_TYPE_RATE_LIMIT:
      return "ERROR_TYPE_RATE_LIMIT";
    case ErrorType.ERROR_TYPE_TIMEOUT:
      return "ERROR_TYPE_TIMEOUT";
    case ErrorType.ERROR_TYPE_NETWORK:
      return "ERROR_TYPE_NETWORK";
    case ErrorType.ERROR_TYPE_INTERNAL:
      return "ERROR_TYPE_INTERNAL";
    case ErrorType.ERROR_TYPE_EXTERNAL:
      return "ERROR_TYPE_EXTERNAL";
    case ErrorType.ERROR_TYPE_CANCELLED:
      return "ERROR_TYPE_CANCELLED";
    case ErrorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** StopStatus 停止状态 */
export enum StopStatus {
  STOP_STATUS_UNSPECIFIED = 0,
  /** STOP_STATUS_STOPPED - 已停止 */
  STOP_STATUS_STOPPED = 1,
  /** STOP_STATUS_STOPPING - 正在停止 */
  STOP_STATUS_STOPPING = 2,
  /** STOP_STATUS_NOT_RUNNING - 未在运行 */
  STOP_STATUS_NOT_RUNNING = 3,
  /** STOP_STATUS_CANNOT_STOP - 无法停止 */
  STOP_STATUS_CANNOT_STOP = 4,
  UNRECOGNIZED = -1,
}

export function stopStatusFromJSON(object: any): StopStatus {
  switch (object) {
    case 0:
    case "STOP_STATUS_UNSPECIFIED":
      return StopStatus.STOP_STATUS_UNSPECIFIED;
    case 1:
    case "STOP_STATUS_STOPPED":
      return StopStatus.STOP_STATUS_STOPPED;
    case 2:
    case "STOP_STATUS_STOPPING":
      return StopStatus.STOP_STATUS_STOPPING;
    case 3:
    case "STOP_STATUS_NOT_RUNNING":
      return StopStatus.STOP_STATUS_NOT_RUNNING;
    case 4:
    case "STOP_STATUS_CANNOT_STOP":
      return StopStatus.STOP_STATUS_CANNOT_STOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StopStatus.UNRECOGNIZED;
  }
}

export function stopStatusToJSON(object: StopStatus): string {
  switch (object) {
    case StopStatus.STOP_STATUS_UNSPECIFIED:
      return "STOP_STATUS_UNSPECIFIED";
    case StopStatus.STOP_STATUS_STOPPED:
      return "STOP_STATUS_STOPPED";
    case StopStatus.STOP_STATUS_STOPPING:
      return "STOP_STATUS_STOPPING";
    case StopStatus.STOP_STATUS_NOT_RUNNING:
      return "STOP_STATUS_NOT_RUNNING";
    case StopStatus.STOP_STATUS_CANNOT_STOP:
      return "STOP_STATUS_CANNOT_STOP";
    case StopStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HealthStatus 健康状态 */
export enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = 0,
  /** HEALTH_STATUS_HEALTHY - 健康 */
  HEALTH_STATUS_HEALTHY = 1,
  /** HEALTH_STATUS_DEGRADED - 降级 */
  HEALTH_STATUS_DEGRADED = 2,
  /** HEALTH_STATUS_UNHEALTHY - 不健康 */
  HEALTH_STATUS_UNHEALTHY = 3,
  UNRECOGNIZED = -1,
}

export function healthStatusFromJSON(object: any): HealthStatus {
  switch (object) {
    case 0:
    case "HEALTH_STATUS_UNSPECIFIED":
      return HealthStatus.HEALTH_STATUS_UNSPECIFIED;
    case 1:
    case "HEALTH_STATUS_HEALTHY":
      return HealthStatus.HEALTH_STATUS_HEALTHY;
    case 2:
    case "HEALTH_STATUS_DEGRADED":
      return HealthStatus.HEALTH_STATUS_DEGRADED;
    case 3:
    case "HEALTH_STATUS_UNHEALTHY":
      return HealthStatus.HEALTH_STATUS_UNHEALTHY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthStatus.UNRECOGNIZED;
  }
}

export function healthStatusToJSON(object: HealthStatus): string {
  switch (object) {
    case HealthStatus.HEALTH_STATUS_UNSPECIFIED:
      return "HEALTH_STATUS_UNSPECIFIED";
    case HealthStatus.HEALTH_STATUS_HEALTHY:
      return "HEALTH_STATUS_HEALTHY";
    case HealthStatus.HEALTH_STATUS_DEGRADED:
      return "HEALTH_STATUS_DEGRADED";
    case HealthStatus.HEALTH_STATUS_UNHEALTHY:
      return "HEALTH_STATUS_UNHEALTHY";
    case HealthStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Value 表示任意类型的值（类似于 google.protobuf.Value，但更精确） */
export interface Value {
  nullValue?: NullValue | undefined;
  stringValue?: string | undefined;
  intValue?: number | undefined;
  doubleValue?: number | undefined;
  boolValue?: boolean | undefined;
  bytesValue?: Buffer | undefined;
  listValue?: ListValue | undefined;
  mapValue?: MapValue | undefined;
}

/** ListValue 表示数组 */
export interface ListValue {
  values: Value[];
}

/** MapValue 表示对象/映射 */
export interface MapValue {
  fields: { [key: string]: Value };
}

export interface MapValue_FieldsEntry {
  key: string;
  value?: Value | undefined;
}

/** ExecutionContext 执行上下文信息 */
export interface ExecutionContext {
  /** 工作流 ID */
  workflowId: string;
  /** 执行实例 ID */
  executionId: string;
  /** 节点 ID */
  nodeId: string;
  /** 追踪 ID（用于分布式追踪） */
  traceId: string;
  /** Span ID */
  spanId: string;
  /** 重试次数（0 表示首次执行） */
  retryCount: number;
  /** 超时时间（毫秒） */
  timeoutMs: number;
  /** 额外元数据 */
  metadata: { [key: string]: string };
}

export interface ExecutionContext_MetadataEntry {
  key: string;
  value: string;
}

export interface GetMetadataRequest {
}

export interface GetMetadataResponse {
  /** 基本信息 */
  name: string;
  /** 显示名称 */
  displayName: string;
  /** 插件描述 */
  description: string;
  /** 插件版本（语义化版本） */
  version: string;
  /** 图标 URL 或 base64 */
  icon: string;
  /** 分类信息 */
  category: NodeCategory;
  /** 节点类型（触发器/处理器） */
  nodeType: NodeType;
  /** 标签（用于搜索） */
  tags: string[];
  /** 参数定义 */
  inputParameters: ParameterDef[];
  /** 输出参数定义 */
  outputParameters: ParameterDef[];
  /** 凭证信息 */
  credentialType: string;
  /** 凭证定义 */
  credentialDef?:
    | CredentialDef
    | undefined;
  /** 能力声明 */
  capabilities?: PluginCapabilities | undefined;
}

/** PluginCapabilities 插件能力声明 */
export interface PluginCapabilities {
  /** 支持流式输出 */
  supportsStreaming: boolean;
  /** 支持取消执行 */
  supportsCancel: boolean;
  /** 支持重试 */
  supportsRetry: boolean;
  /** 支持批量处理 */
  supportsBatch: boolean;
  /** 需要凭证 */
  requiresCredential: boolean;
  /** 最大并发数（0 表示无限制） */
  maxConcurrent: number;
  /** 默认超时时间 */
  defaultTimeoutMs: number;
}

/** ParameterDef 参数定义 */
export interface ParameterDef {
  /** 参数名称 */
  name: string;
  /** 显示名称 */
  displayName: string;
  /** 参数描述 */
  description: string;
  /** 参数类型 */
  type: ParameterType;
  /** 是否必填 */
  required: boolean;
  /** 默认值 */
  defaultValue?:
    | Value
    | undefined;
  /** 验证规则 */
  validation?:
    | ParameterValidation
    | undefined;
  /** UI 相关 */
  placeholder: string;
  /** 提示信息 */
  hint: string;
  /** UI 展示类型 */
  uiType: ParameterUIType;
  /** 枚举选项（用于下拉框等） */
  options: ParameterOption[];
  /** 参数分组 */
  group: string;
  /** 显示顺序 */
  order: number;
  /** 条件显示 */
  dependsOn: string;
  /** 显示条件表达式 */
  showWhen: string;
}

/** ParameterOption 参数选项（用于枚举类型） */
export interface ParameterOption {
  /** 值 */
  value: string;
  /** 显示标签 */
  label: string;
  /** 描述 */
  description: string;
  /** 图标 */
  icon: string;
  /** 是否禁用 */
  disabled: boolean;
}

/** ParameterValidation 参数验证规则 */
export interface ParameterValidation {
  /** 字符串验证 */
  minLength: number;
  maxLength: number;
  /** 正则表达式 */
  pattern: string;
  /** 数值验证 */
  minValue: number;
  maxValue: number;
  /** 数组验证 */
  minItems: number;
  maxItems: number;
  /** 通用 */
  allowedValues: string[];
  /** 自定义验证器表达式 */
  customValidator: string;
}

/** CredentialDef 凭证定义 */
export interface CredentialDef {
  /** 凭证类型 */
  type: string;
  /** 显示名称 */
  displayName: string;
  /** 描述 */
  description: string;
  /** 凭证字段定义 */
  fields: ParameterDef[];
  /** OAuth 认证 URL（如果是 OAuth） */
  authUrl: string;
  /** OAuth Token URL */
  tokenUrl: string;
}

export interface InitRequest {
  /** 执行上下文 */
  context?:
    | ExecutionContext
    | undefined;
  /** 节点配置 */
  nodeConfig?:
    | NodeConfig
    | undefined;
  /** 工作流配置 */
  workflowConfig?:
    | WorkflowConfig
    | undefined;
  /** 服务端 API 地址 */
  serverEndpoint: string;
  /** 凭证信息 */
  credential?: Credential | undefined;
}

/** NodeConfig 节点配置 */
export interface NodeConfig {
  /** 节点 ID */
  id: string;
  /** 节点名称 */
  name: string;
  /** 节点类型（插件名称） */
  kind: string;
  /** 节点参数 */
  parameters: { [key: string]: Value };
  /** 标签 */
  labels: { [key: string]: string };
  /** 位置信息（用于可视化） */
  position?: NodePosition | undefined;
}

export interface NodeConfig_ParametersEntry {
  key: string;
  value?: Value | undefined;
}

export interface NodeConfig_LabelsEntry {
  key: string;
  value: string;
}

/** NodePosition 节点位置 */
export interface NodePosition {
  x: number;
  y: number;
}

/** WorkflowConfig 工作流配置 */
export interface WorkflowConfig {
  /** 工作流 ID */
  id: string;
  /** 工作流名称 */
  name: string;
  /** 工作流版本 */
  version: string;
  /** 全局变量 */
  globalVars: { [key: string]: Value };
  /** 环境变量 */
  env: { [key: string]: string };
}

export interface WorkflowConfig_GlobalVarsEntry {
  key: string;
  value?: Value | undefined;
}

export interface WorkflowConfig_EnvEntry {
  key: string;
  value: string;
}

/** Credential 凭证信息 */
export interface Credential {
  /** 凭证类型 */
  type: string;
  /** 凭证字段 */
  fields: { [key: string]: Value };
  /** 过期时间（毫秒时间戳） */
  expiresAtMs: number;
}

export interface Credential_FieldsEntry {
  key: string;
  value?: Value | undefined;
}

export interface InitResponse {
  success: boolean;
  /** 错误码 */
  errorCode: string;
  /** 错误信息 */
  errorMessage: string;
  /** 初始化后的元数据 */
  metadata: { [key: string]: string };
}

export interface InitResponse_MetadataEntry {
  key: string;
  value: string;
}

export interface RunRequest {
  /** 执行上下文 */
  context?:
    | ExecutionContext
    | undefined;
  /** 参数值 */
  parameters: { [key: string]: Value };
  /** 父节点输出 */
  parentOutput: { [key: string]: Value };
  /** 全局变量 */
  globalVars: { [key: string]: Value };
  /** 本地变量 */
  localVars: { [key: string]: Value };
}

export interface RunRequest_ParametersEntry {
  key: string;
  value?: Value | undefined;
}

export interface RunRequest_ParentOutputEntry {
  key: string;
  value?: Value | undefined;
}

export interface RunRequest_GlobalVarsEntry {
  key: string;
  value?: Value | undefined;
}

export interface RunRequest_LocalVarsEntry {
  key: string;
  value?: Value | undefined;
}

export interface RunResponse {
  type: ResponseType;
  /** 时间戳（毫秒） */
  timestampMs: number;
  /** 日志消息 */
  log?:
    | LogPayload
    | undefined;
  /** 进度更新 */
  progress?:
    | ProgressPayload
    | undefined;
  /** 执行结果 */
  result?:
    | ResultPayload
    | undefined;
  /** 错误信息 */
  error?: ErrorPayload | undefined;
}

/** LogPayload 日志消息 */
export interface LogPayload {
  level: LogLevel;
  message: string;
  /** 结构化日志字段 */
  fields: { [key: string]: string };
}

export interface LogPayload_FieldsEntry {
  key: string;
  value: string;
}

/** ProgressPayload 进度更新 */
export interface ProgressPayload {
  /** 当前进度 */
  current: number;
  /** 总进度 */
  total: number;
  /** 进度消息 */
  message: string;
  /** 百分比 (0-100) */
  percentage: number;
}

/** ResultPayload 执行结果 */
export interface ResultPayload {
  /** 输出数据 */
  output: { [key: string]: Value };
  /** 分支索引（用于条件分支） */
  branchIndex: number;
  /** 下一个节点 ID（可选） */
  nextNodeId: string;
  /** 执行状态 */
  status: ExecutionStatus;
  /** 执行耗时（毫秒） */
  durationMs: number;
}

export interface ResultPayload_OutputEntry {
  key: string;
  value?: Value | undefined;
}

/** ErrorPayload 错误信息 */
export interface ErrorPayload {
  /** 错误码 */
  code: string;
  /** 错误消息 */
  message: string;
  /** 错误类型 */
  errorType: ErrorType;
  /** 是否可重试 */
  retryable: boolean;
  /** 重试等待时间 */
  retryAfterMs: number;
  /** 错误详情 */
  details: { [key: string]: string };
  /** 堆栈跟踪（仅开发环境） */
  stackTrace: string;
}

export interface ErrorPayload_DetailsEntry {
  key: string;
  value: string;
}

export interface StopRequest {
  /** 执行上下文 */
  context?:
    | ExecutionContext
    | undefined;
  /** 停止原因 */
  reason: string;
  /** 是否强制停止 */
  force: boolean;
}

export interface StopResponse {
  success: boolean;
  message: string;
  status: StopStatus;
}

export interface TestCredentialRequest {
  /** 凭证类型 */
  credentialType: string;
  /** 凭证信息 */
  credential?:
    | Credential
    | undefined;
  /** 超时时间 */
  timeoutMs: number;
}

export interface TestCredentialResponse {
  success: boolean;
  errorCode: string;
  errorMessage: string;
  /** 附加信息（如用户名、账户ID等） */
  info: { [key: string]: string };
}

export interface TestCredentialResponse_InfoEntry {
  key: string;
  value: string;
}

export interface HealthCheckRequest {
  /** 是否包含详细信息 */
  includeDetails: boolean;
}

export interface HealthCheckResponse {
  /** 健康状态 */
  status: HealthStatus;
  /** 状态消息 */
  message: string;
  /** 版本信息 */
  pluginVersion: string;
  /** 协议版本 */
  protocolVersion: string;
  /** 能力信息 */
  supportedFeatures: string[];
  /** 详细信息 */
  details: { [key: string]: HealthCheckDetail };
  /** 资源使用 */
  resourceUsage?:
    | ResourceUsage
    | undefined;
  /** 检查时间（毫秒时间戳） */
  checkedAtMs: number;
}

export interface HealthCheckResponse_DetailsEntry {
  key: string;
  value?: HealthCheckDetail | undefined;
}

/** HealthCheckDetail 健康检查详情 */
export interface HealthCheckDetail {
  status: HealthStatus;
  message: string;
  /** 延迟（毫秒） */
  latencyMs: number;
}

/** ResourceUsage 资源使用情况 */
export interface ResourceUsage {
  /** 内存使用（字节） */
  memoryBytes: number;
  /** CPU 使用率 */
  cpuPercent: number;
  /** Goroutine 数量 */
  goroutines: number;
  /** 活动连接数 */
  activeConnections: number;
}

function createBaseValue(): Value {
  return {
    nullValue: undefined,
    stringValue: undefined,
    intValue: undefined,
    doubleValue: undefined,
    boolValue: undefined,
    bytesValue: undefined,
    listValue: undefined,
    mapValue: undefined,
  };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nullValue !== undefined) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(24).int64(message.intValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(33).double(message.doubleValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(40).bool(message.boolValue);
    }
    if (message.bytesValue !== undefined) {
      writer.uint32(50).bytes(message.bytesValue);
    }
    if (message.listValue !== undefined) {
      ListValue.encode(message.listValue, writer.uint32(58).fork()).join();
    }
    if (message.mapValue !== undefined) {
      MapValue.encode(message.mapValue, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nullValue = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.intValue = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bytesValue = Buffer.from(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.listValue = ListValue.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mapValue = MapValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      bytesValue: isSet(object.bytesValue) ? Buffer.from(bytesFromBase64(object.bytesValue)) : undefined,
      listValue: isSet(object.listValue) ? ListValue.fromJSON(object.listValue) : undefined,
      mapValue: isSet(object.mapValue) ? MapValue.fromJSON(object.mapValue) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.nullValue !== undefined) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.bytesValue !== undefined) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.listValue !== undefined) {
      obj.listValue = ListValue.toJSON(message.listValue);
    }
    if (message.mapValue !== undefined) {
      obj.mapValue = MapValue.toJSON(message.mapValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {
    return Value.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {
    const message = createBaseValue();
    message.nullValue = object.nullValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.bytesValue = object.bytesValue ?? undefined;
    message.listValue = (object.listValue !== undefined && object.listValue !== null)
      ? ListValue.fromPartial(object.listValue)
      : undefined;
    message.mapValue = (object.mapValue !== undefined && object.mapValue !== null)
      ? MapValue.fromPartial(object.mapValue)
      : undefined;
    return message;
  },
};

function createBaseListValue(): ListValue {
  return { values: [] };
}

export const ListValue: MessageFns<ListValue> = {
  encode(message: ListValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListValue {
    return { values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [] };
  },

  toJSON(message: ListValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListValue>, I>>(base?: I): ListValue {
    return ListValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListValue>, I>>(object: I): ListValue {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMapValue(): MapValue {
  return { fields: {} };
}

export const MapValue: MessageFns<MapValue> = {
  encode(message: MapValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.fields).forEach(([key, value]) => {
      MapValue_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MapValue_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValue {
    return {
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapValue): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValue>, I>>(base?: I): MapValue {
    return MapValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValue>, I>>(object: I): MapValue {
    const message = createBaseMapValue();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapValue_FieldsEntry(): MapValue_FieldsEntry {
  return { key: "", value: undefined };
}

export const MapValue_FieldsEntry: MessageFns<MapValue_FieldsEntry> = {
  encode(message: MapValue_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValue_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValue_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValue_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MapValue_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValue_FieldsEntry>, I>>(base?: I): MapValue_FieldsEntry {
    return MapValue_FieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValue_FieldsEntry>, I>>(object: I): MapValue_FieldsEntry {
    const message = createBaseMapValue_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseExecutionContext(): ExecutionContext {
  return {
    workflowId: "",
    executionId: "",
    nodeId: "",
    traceId: "",
    spanId: "",
    retryCount: 0,
    timeoutMs: 0,
    metadata: {},
  };
}

export const ExecutionContext: MessageFns<ExecutionContext> = {
  encode(message: ExecutionContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowId !== "") {
      writer.uint32(10).string(message.workflowId);
    }
    if (message.executionId !== "") {
      writer.uint32(18).string(message.executionId);
    }
    if (message.nodeId !== "") {
      writer.uint32(26).string(message.nodeId);
    }
    if (message.traceId !== "") {
      writer.uint32(34).string(message.traceId);
    }
    if (message.spanId !== "") {
      writer.uint32(42).string(message.spanId);
    }
    if (message.retryCount !== 0) {
      writer.uint32(48).int32(message.retryCount);
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(56).int64(message.timeoutMs);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ExecutionContext_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workflowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.traceId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.spanId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timeoutMs = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = ExecutionContext_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionContext {
    return {
      workflowId: isSet(object.workflowId) ? globalThis.String(object.workflowId) : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ExecutionContext): unknown {
    const obj: any = {};
    if (message.workflowId !== "") {
      obj.workflowId = message.workflowId;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionContext>, I>>(base?: I): ExecutionContext {
    return ExecutionContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionContext>, I>>(object: I): ExecutionContext {
    const message = createBaseExecutionContext();
    message.workflowId = object.workflowId ?? "";
    message.executionId = object.executionId ?? "";
    message.nodeId = object.nodeId ?? "";
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? "";
    message.retryCount = object.retryCount ?? 0;
    message.timeoutMs = object.timeoutMs ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseExecutionContext_MetadataEntry(): ExecutionContext_MetadataEntry {
  return { key: "", value: "" };
}

export const ExecutionContext_MetadataEntry: MessageFns<ExecutionContext_MetadataEntry> = {
  encode(message: ExecutionContext_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionContext_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionContext_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionContext_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ExecutionContext_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionContext_MetadataEntry>, I>>(base?: I): ExecutionContext_MetadataEntry {
    return ExecutionContext_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionContext_MetadataEntry>, I>>(
    object: I,
  ): ExecutionContext_MetadataEntry {
    const message = createBaseExecutionContext_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetMetadataRequest(): GetMetadataRequest {
  return {};
}

export const GetMetadataRequest: MessageFns<GetMetadataRequest> = {
  encode(_: GetMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMetadataRequest {
    return {};
  },

  toJSON(_: GetMetadataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetadataRequest>, I>>(base?: I): GetMetadataRequest {
    return GetMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetadataRequest>, I>>(_: I): GetMetadataRequest {
    const message = createBaseGetMetadataRequest();
    return message;
  },
};

function createBaseGetMetadataResponse(): GetMetadataResponse {
  return {
    name: "",
    displayName: "",
    description: "",
    version: "",
    icon: "",
    category: 0,
    nodeType: 0,
    tags: [],
    inputParameters: [],
    outputParameters: [],
    credentialType: "",
    credentialDef: undefined,
    capabilities: undefined,
  };
}

export const GetMetadataResponse: MessageFns<GetMetadataResponse> = {
  encode(message: GetMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.icon !== "") {
      writer.uint32(42).string(message.icon);
    }
    if (message.category !== 0) {
      writer.uint32(48).int32(message.category);
    }
    if (message.nodeType !== 0) {
      writer.uint32(56).int32(message.nodeType);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.inputParameters) {
      ParameterDef.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.outputParameters) {
      ParameterDef.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.credentialType !== "") {
      writer.uint32(122).string(message.credentialType);
    }
    if (message.credentialDef !== undefined) {
      CredentialDef.encode(message.credentialDef, writer.uint32(130).fork()).join();
    }
    if (message.capabilities !== undefined) {
      PluginCapabilities.encode(message.capabilities, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.nodeType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.inputParameters.push(ParameterDef.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.outputParameters.push(ParameterDef.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.credentialType = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.credentialDef = CredentialDef.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.capabilities = PluginCapabilities.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetadataResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      category: isSet(object.category) ? nodeCategoryFromJSON(object.category) : 0,
      nodeType: isSet(object.nodeType) ? nodeTypeFromJSON(object.nodeType) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      inputParameters: globalThis.Array.isArray(object?.inputParameters)
        ? object.inputParameters.map((e: any) => ParameterDef.fromJSON(e))
        : [],
      outputParameters: globalThis.Array.isArray(object?.outputParameters)
        ? object.outputParameters.map((e: any) => ParameterDef.fromJSON(e))
        : [],
      credentialType: isSet(object.credentialType) ? globalThis.String(object.credentialType) : "",
      credentialDef: isSet(object.credentialDef) ? CredentialDef.fromJSON(object.credentialDef) : undefined,
      capabilities: isSet(object.capabilities) ? PluginCapabilities.fromJSON(object.capabilities) : undefined,
    };
  },

  toJSON(message: GetMetadataResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.category !== 0) {
      obj.category = nodeCategoryToJSON(message.category);
    }
    if (message.nodeType !== 0) {
      obj.nodeType = nodeTypeToJSON(message.nodeType);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.inputParameters?.length) {
      obj.inputParameters = message.inputParameters.map((e) => ParameterDef.toJSON(e));
    }
    if (message.outputParameters?.length) {
      obj.outputParameters = message.outputParameters.map((e) => ParameterDef.toJSON(e));
    }
    if (message.credentialType !== "") {
      obj.credentialType = message.credentialType;
    }
    if (message.credentialDef !== undefined) {
      obj.credentialDef = CredentialDef.toJSON(message.credentialDef);
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = PluginCapabilities.toJSON(message.capabilities);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMetadataResponse>, I>>(base?: I): GetMetadataResponse {
    return GetMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMetadataResponse>, I>>(object: I): GetMetadataResponse {
    const message = createBaseGetMetadataResponse();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.version = object.version ?? "";
    message.icon = object.icon ?? "";
    message.category = object.category ?? 0;
    message.nodeType = object.nodeType ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.inputParameters = object.inputParameters?.map((e) => ParameterDef.fromPartial(e)) || [];
    message.outputParameters = object.outputParameters?.map((e) => ParameterDef.fromPartial(e)) || [];
    message.credentialType = object.credentialType ?? "";
    message.credentialDef = (object.credentialDef !== undefined && object.credentialDef !== null)
      ? CredentialDef.fromPartial(object.credentialDef)
      : undefined;
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? PluginCapabilities.fromPartial(object.capabilities)
      : undefined;
    return message;
  },
};

function createBasePluginCapabilities(): PluginCapabilities {
  return {
    supportsStreaming: false,
    supportsCancel: false,
    supportsRetry: false,
    supportsBatch: false,
    requiresCredential: false,
    maxConcurrent: 0,
    defaultTimeoutMs: 0,
  };
}

export const PluginCapabilities: MessageFns<PluginCapabilities> = {
  encode(message: PluginCapabilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.supportsStreaming !== false) {
      writer.uint32(8).bool(message.supportsStreaming);
    }
    if (message.supportsCancel !== false) {
      writer.uint32(16).bool(message.supportsCancel);
    }
    if (message.supportsRetry !== false) {
      writer.uint32(24).bool(message.supportsRetry);
    }
    if (message.supportsBatch !== false) {
      writer.uint32(32).bool(message.supportsBatch);
    }
    if (message.requiresCredential !== false) {
      writer.uint32(40).bool(message.requiresCredential);
    }
    if (message.maxConcurrent !== 0) {
      writer.uint32(48).int32(message.maxConcurrent);
    }
    if (message.defaultTimeoutMs !== 0) {
      writer.uint32(56).int32(message.defaultTimeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluginCapabilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluginCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.supportsStreaming = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.supportsCancel = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportsRetry = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.supportsBatch = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.requiresCredential = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxConcurrent = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.defaultTimeoutMs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PluginCapabilities {
    return {
      supportsStreaming: isSet(object.supportsStreaming) ? globalThis.Boolean(object.supportsStreaming) : false,
      supportsCancel: isSet(object.supportsCancel) ? globalThis.Boolean(object.supportsCancel) : false,
      supportsRetry: isSet(object.supportsRetry) ? globalThis.Boolean(object.supportsRetry) : false,
      supportsBatch: isSet(object.supportsBatch) ? globalThis.Boolean(object.supportsBatch) : false,
      requiresCredential: isSet(object.requiresCredential) ? globalThis.Boolean(object.requiresCredential) : false,
      maxConcurrent: isSet(object.maxConcurrent) ? globalThis.Number(object.maxConcurrent) : 0,
      defaultTimeoutMs: isSet(object.defaultTimeoutMs) ? globalThis.Number(object.defaultTimeoutMs) : 0,
    };
  },

  toJSON(message: PluginCapabilities): unknown {
    const obj: any = {};
    if (message.supportsStreaming !== false) {
      obj.supportsStreaming = message.supportsStreaming;
    }
    if (message.supportsCancel !== false) {
      obj.supportsCancel = message.supportsCancel;
    }
    if (message.supportsRetry !== false) {
      obj.supportsRetry = message.supportsRetry;
    }
    if (message.supportsBatch !== false) {
      obj.supportsBatch = message.supportsBatch;
    }
    if (message.requiresCredential !== false) {
      obj.requiresCredential = message.requiresCredential;
    }
    if (message.maxConcurrent !== 0) {
      obj.maxConcurrent = Math.round(message.maxConcurrent);
    }
    if (message.defaultTimeoutMs !== 0) {
      obj.defaultTimeoutMs = Math.round(message.defaultTimeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PluginCapabilities>, I>>(base?: I): PluginCapabilities {
    return PluginCapabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PluginCapabilities>, I>>(object: I): PluginCapabilities {
    const message = createBasePluginCapabilities();
    message.supportsStreaming = object.supportsStreaming ?? false;
    message.supportsCancel = object.supportsCancel ?? false;
    message.supportsRetry = object.supportsRetry ?? false;
    message.supportsBatch = object.supportsBatch ?? false;
    message.requiresCredential = object.requiresCredential ?? false;
    message.maxConcurrent = object.maxConcurrent ?? 0;
    message.defaultTimeoutMs = object.defaultTimeoutMs ?? 0;
    return message;
  },
};

function createBaseParameterDef(): ParameterDef {
  return {
    name: "",
    displayName: "",
    description: "",
    type: 0,
    required: false,
    defaultValue: undefined,
    validation: undefined,
    placeholder: "",
    hint: "",
    uiType: 0,
    options: [],
    group: "",
    order: 0,
    dependsOn: "",
    showWhen: "",
  };
}

export const ParameterDef: MessageFns<ParameterDef> = {
  encode(message: ParameterDef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.required !== false) {
      writer.uint32(40).bool(message.required);
    }
    if (message.defaultValue !== undefined) {
      Value.encode(message.defaultValue, writer.uint32(50).fork()).join();
    }
    if (message.validation !== undefined) {
      ParameterValidation.encode(message.validation, writer.uint32(82).fork()).join();
    }
    if (message.placeholder !== "") {
      writer.uint32(122).string(message.placeholder);
    }
    if (message.hint !== "") {
      writer.uint32(130).string(message.hint);
    }
    if (message.uiType !== 0) {
      writer.uint32(136).int32(message.uiType);
    }
    for (const v of message.options) {
      ParameterOption.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.group !== "") {
      writer.uint32(154).string(message.group);
    }
    if (message.order !== 0) {
      writer.uint32(160).int32(message.order);
    }
    if (message.dependsOn !== "") {
      writer.uint32(202).string(message.dependsOn);
    }
    if (message.showWhen !== "") {
      writer.uint32(210).string(message.showWhen);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterDef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.defaultValue = Value.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.validation = ParameterValidation.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.placeholder = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.hint = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.uiType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.options.push(ParameterOption.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.dependsOn = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.showWhen = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterDef {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? parameterTypeFromJSON(object.type) : 0,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      defaultValue: isSet(object.defaultValue) ? Value.fromJSON(object.defaultValue) : undefined,
      validation: isSet(object.validation) ? ParameterValidation.fromJSON(object.validation) : undefined,
      placeholder: isSet(object.placeholder) ? globalThis.String(object.placeholder) : "",
      hint: isSet(object.hint) ? globalThis.String(object.hint) : "",
      uiType: isSet(object.uiType) ? parameterUITypeFromJSON(object.uiType) : 0,
      options: globalThis.Array.isArray(object?.options)
        ? object.options.map((e: any) => ParameterOption.fromJSON(e))
        : [],
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      dependsOn: isSet(object.dependsOn) ? globalThis.String(object.dependsOn) : "",
      showWhen: isSet(object.showWhen) ? globalThis.String(object.showWhen) : "",
    };
  },

  toJSON(message: ParameterDef): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = parameterTypeToJSON(message.type);
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = Value.toJSON(message.defaultValue);
    }
    if (message.validation !== undefined) {
      obj.validation = ParameterValidation.toJSON(message.validation);
    }
    if (message.placeholder !== "") {
      obj.placeholder = message.placeholder;
    }
    if (message.hint !== "") {
      obj.hint = message.hint;
    }
    if (message.uiType !== 0) {
      obj.uiType = parameterUITypeToJSON(message.uiType);
    }
    if (message.options?.length) {
      obj.options = message.options.map((e) => ParameterOption.toJSON(e));
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.dependsOn !== "") {
      obj.dependsOn = message.dependsOn;
    }
    if (message.showWhen !== "") {
      obj.showWhen = message.showWhen;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterDef>, I>>(base?: I): ParameterDef {
    return ParameterDef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterDef>, I>>(object: I): ParameterDef {
    const message = createBaseParameterDef();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.required = object.required ?? false;
    message.defaultValue = (object.defaultValue !== undefined && object.defaultValue !== null)
      ? Value.fromPartial(object.defaultValue)
      : undefined;
    message.validation = (object.validation !== undefined && object.validation !== null)
      ? ParameterValidation.fromPartial(object.validation)
      : undefined;
    message.placeholder = object.placeholder ?? "";
    message.hint = object.hint ?? "";
    message.uiType = object.uiType ?? 0;
    message.options = object.options?.map((e) => ParameterOption.fromPartial(e)) || [];
    message.group = object.group ?? "";
    message.order = object.order ?? 0;
    message.dependsOn = object.dependsOn ?? "";
    message.showWhen = object.showWhen ?? "";
    return message;
  },
};

function createBaseParameterOption(): ParameterOption {
  return { value: "", label: "", description: "", icon: "", disabled: false };
}

export const ParameterOption: MessageFns<ParameterOption> = {
  encode(message: ParameterOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.icon !== "") {
      writer.uint32(34).string(message.icon);
    }
    if (message.disabled !== false) {
      writer.uint32(40).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icon = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterOption {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      icon: isSet(object.icon) ? globalThis.String(object.icon) : "",
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: ParameterOption): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.icon !== "") {
      obj.icon = message.icon;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterOption>, I>>(base?: I): ParameterOption {
    return ParameterOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterOption>, I>>(object: I): ParameterOption {
    const message = createBaseParameterOption();
    message.value = object.value ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.icon = object.icon ?? "";
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseParameterValidation(): ParameterValidation {
  return {
    minLength: 0,
    maxLength: 0,
    pattern: "",
    minValue: 0,
    maxValue: 0,
    minItems: 0,
    maxItems: 0,
    allowedValues: [],
    customValidator: "",
  };
}

export const ParameterValidation: MessageFns<ParameterValidation> = {
  encode(message: ParameterValidation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minLength !== 0) {
      writer.uint32(8).int32(message.minLength);
    }
    if (message.maxLength !== 0) {
      writer.uint32(16).int32(message.maxLength);
    }
    if (message.pattern !== "") {
      writer.uint32(26).string(message.pattern);
    }
    if (message.minValue !== 0) {
      writer.uint32(81).double(message.minValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(89).double(message.maxValue);
    }
    if (message.minItems !== 0) {
      writer.uint32(160).int32(message.minItems);
    }
    if (message.maxItems !== 0) {
      writer.uint32(168).int32(message.maxItems);
    }
    for (const v of message.allowedValues) {
      writer.uint32(242).string(v!);
    }
    if (message.customValidator !== "") {
      writer.uint32(250).string(message.customValidator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterValidation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minLength = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxLength = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.minValue = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.maxValue = reader.double();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.minItems = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.maxItems = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.allowedValues.push(reader.string());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.customValidator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterValidation {
    return {
      minLength: isSet(object.minLength) ? globalThis.Number(object.minLength) : 0,
      maxLength: isSet(object.maxLength) ? globalThis.Number(object.maxLength) : 0,
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
      minItems: isSet(object.minItems) ? globalThis.Number(object.minItems) : 0,
      maxItems: isSet(object.maxItems) ? globalThis.Number(object.maxItems) : 0,
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => globalThis.String(e))
        : [],
      customValidator: isSet(object.customValidator) ? globalThis.String(object.customValidator) : "",
    };
  },

  toJSON(message: ParameterValidation): unknown {
    const obj: any = {};
    if (message.minLength !== 0) {
      obj.minLength = Math.round(message.minLength);
    }
    if (message.maxLength !== 0) {
      obj.maxLength = Math.round(message.maxLength);
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== 0) {
      obj.maxValue = message.maxValue;
    }
    if (message.minItems !== 0) {
      obj.minItems = Math.round(message.minItems);
    }
    if (message.maxItems !== 0) {
      obj.maxItems = Math.round(message.maxItems);
    }
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues;
    }
    if (message.customValidator !== "") {
      obj.customValidator = message.customValidator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterValidation>, I>>(base?: I): ParameterValidation {
    return ParameterValidation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterValidation>, I>>(object: I): ParameterValidation {
    const message = createBaseParameterValidation();
    message.minLength = object.minLength ?? 0;
    message.maxLength = object.maxLength ?? 0;
    message.pattern = object.pattern ?? "";
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    message.minItems = object.minItems ?? 0;
    message.maxItems = object.maxItems ?? 0;
    message.allowedValues = object.allowedValues?.map((e) => e) || [];
    message.customValidator = object.customValidator ?? "";
    return message;
  },
};

function createBaseCredentialDef(): CredentialDef {
  return { type: "", displayName: "", description: "", fields: [], authUrl: "", tokenUrl: "" };
}

export const CredentialDef: MessageFns<CredentialDef> = {
  encode(message: CredentialDef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.fields) {
      ParameterDef.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.authUrl !== "") {
      writer.uint32(42).string(message.authUrl);
    }
    if (message.tokenUrl !== "") {
      writer.uint32(50).string(message.tokenUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CredentialDef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentialDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fields.push(ParameterDef.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CredentialDef {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => ParameterDef.fromJSON(e)) : [],
      authUrl: isSet(object.authUrl) ? globalThis.String(object.authUrl) : "",
      tokenUrl: isSet(object.tokenUrl) ? globalThis.String(object.tokenUrl) : "",
    };
  },

  toJSON(message: CredentialDef): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => ParameterDef.toJSON(e));
    }
    if (message.authUrl !== "") {
      obj.authUrl = message.authUrl;
    }
    if (message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CredentialDef>, I>>(base?: I): CredentialDef {
    return CredentialDef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CredentialDef>, I>>(object: I): CredentialDef {
    const message = createBaseCredentialDef();
    message.type = object.type ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.fields = object.fields?.map((e) => ParameterDef.fromPartial(e)) || [];
    message.authUrl = object.authUrl ?? "";
    message.tokenUrl = object.tokenUrl ?? "";
    return message;
  },
};

function createBaseInitRequest(): InitRequest {
  return {
    context: undefined,
    nodeConfig: undefined,
    workflowConfig: undefined,
    serverEndpoint: "",
    credential: undefined,
  };
}

export const InitRequest: MessageFns<InitRequest> = {
  encode(message: InitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.nodeConfig !== undefined) {
      NodeConfig.encode(message.nodeConfig, writer.uint32(18).fork()).join();
    }
    if (message.workflowConfig !== undefined) {
      WorkflowConfig.encode(message.workflowConfig, writer.uint32(26).fork()).join();
    }
    if (message.serverEndpoint !== "") {
      writer.uint32(34).string(message.serverEndpoint);
    }
    if (message.credential !== undefined) {
      Credential.encode(message.credential, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeConfig = NodeConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workflowConfig = WorkflowConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serverEndpoint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.credential = Credential.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitRequest {
    return {
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
      nodeConfig: isSet(object.nodeConfig) ? NodeConfig.fromJSON(object.nodeConfig) : undefined,
      workflowConfig: isSet(object.workflowConfig) ? WorkflowConfig.fromJSON(object.workflowConfig) : undefined,
      serverEndpoint: isSet(object.serverEndpoint) ? globalThis.String(object.serverEndpoint) : "",
      credential: isSet(object.credential) ? Credential.fromJSON(object.credential) : undefined,
    };
  },

  toJSON(message: InitRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = NodeConfig.toJSON(message.nodeConfig);
    }
    if (message.workflowConfig !== undefined) {
      obj.workflowConfig = WorkflowConfig.toJSON(message.workflowConfig);
    }
    if (message.serverEndpoint !== "") {
      obj.serverEndpoint = message.serverEndpoint;
    }
    if (message.credential !== undefined) {
      obj.credential = Credential.toJSON(message.credential);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitRequest>, I>>(base?: I): InitRequest {
    return InitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitRequest>, I>>(object: I): InitRequest {
    const message = createBaseInitRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? NodeConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.workflowConfig = (object.workflowConfig !== undefined && object.workflowConfig !== null)
      ? WorkflowConfig.fromPartial(object.workflowConfig)
      : undefined;
    message.serverEndpoint = object.serverEndpoint ?? "";
    message.credential = (object.credential !== undefined && object.credential !== null)
      ? Credential.fromPartial(object.credential)
      : undefined;
    return message;
  },
};

function createBaseNodeConfig(): NodeConfig {
  return { id: "", name: "", kind: "", parameters: {}, labels: {}, position: undefined };
}

export const NodeConfig: MessageFns<NodeConfig> = {
  encode(message: NodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.kind !== "") {
      writer.uint32(26).string(message.kind);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      NodeConfig_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      NodeConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.position !== undefined) {
      NodePosition.encode(message.position, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kind = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = NodeConfig_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = NodeConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.position = NodePosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      position: isSet(object.position) ? NodePosition.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Value.toJSON(v);
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.position !== undefined) {
      obj.position = NodePosition.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeConfig>, I>>(base?: I): NodeConfig {
    return NodeConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeConfig>, I>>(object: I): NodeConfig {
    const message = createBaseNodeConfig();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.kind = object.kind ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.position = (object.position !== undefined && object.position !== null)
      ? NodePosition.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseNodeConfig_ParametersEntry(): NodeConfig_ParametersEntry {
  return { key: "", value: undefined };
}

export const NodeConfig_ParametersEntry: MessageFns<NodeConfig_ParametersEntry> = {
  encode(message: NodeConfig_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NodeConfig_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeConfig_ParametersEntry>, I>>(base?: I): NodeConfig_ParametersEntry {
    return NodeConfig_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeConfig_ParametersEntry>, I>>(object: I): NodeConfig_ParametersEntry {
    const message = createBaseNodeConfig_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseNodeConfig_LabelsEntry(): NodeConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const NodeConfig_LabelsEntry: MessageFns<NodeConfig_LabelsEntry> = {
  encode(message: NodeConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeConfig_LabelsEntry>, I>>(base?: I): NodeConfig_LabelsEntry {
    return NodeConfig_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeConfig_LabelsEntry>, I>>(object: I): NodeConfig_LabelsEntry {
    const message = createBaseNodeConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodePosition(): NodePosition {
  return { x: 0, y: 0 };
}

export const NodePosition: MessageFns<NodePosition> = {
  encode(message: NodePosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePosition {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: NodePosition): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodePosition>, I>>(base?: I): NodePosition {
    return NodePosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodePosition>, I>>(object: I): NodePosition {
    const message = createBaseNodePosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseWorkflowConfig(): WorkflowConfig {
  return { id: "", name: "", version: "", globalVars: {}, env: {} };
}

export const WorkflowConfig: MessageFns<WorkflowConfig> = {
  encode(message: WorkflowConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    Object.entries(message.globalVars).forEach(([key, value]) => {
      WorkflowConfig_GlobalVarsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.env).forEach(([key, value]) => {
      WorkflowConfig_EnvEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = WorkflowConfig_GlobalVarsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.globalVars[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = WorkflowConfig_EnvEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.env[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      globalVars: isObject(object.globalVars)
        ? Object.entries(object.globalVars).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      env: isObject(object.env)
        ? Object.entries(object.env).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: WorkflowConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.globalVars) {
      const entries = Object.entries(message.globalVars);
      if (entries.length > 0) {
        obj.globalVars = {};
        entries.forEach(([k, v]) => {
          obj.globalVars[k] = Value.toJSON(v);
        });
      }
    }
    if (message.env) {
      const entries = Object.entries(message.env);
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowConfig>, I>>(base?: I): WorkflowConfig {
    return WorkflowConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowConfig>, I>>(object: I): WorkflowConfig {
    const message = createBaseWorkflowConfig();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.globalVars = Object.entries(object.globalVars ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.env = Object.entries(object.env ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorkflowConfig_GlobalVarsEntry(): WorkflowConfig_GlobalVarsEntry {
  return { key: "", value: undefined };
}

export const WorkflowConfig_GlobalVarsEntry: MessageFns<WorkflowConfig_GlobalVarsEntry> = {
  encode(message: WorkflowConfig_GlobalVarsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowConfig_GlobalVarsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowConfig_GlobalVarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowConfig_GlobalVarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WorkflowConfig_GlobalVarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowConfig_GlobalVarsEntry>, I>>(base?: I): WorkflowConfig_GlobalVarsEntry {
    return WorkflowConfig_GlobalVarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowConfig_GlobalVarsEntry>, I>>(
    object: I,
  ): WorkflowConfig_GlobalVarsEntry {
    const message = createBaseWorkflowConfig_GlobalVarsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseWorkflowConfig_EnvEntry(): WorkflowConfig_EnvEntry {
  return { key: "", value: "" };
}

export const WorkflowConfig_EnvEntry: MessageFns<WorkflowConfig_EnvEntry> = {
  encode(message: WorkflowConfig_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowConfig_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowConfig_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowConfig_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkflowConfig_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowConfig_EnvEntry>, I>>(base?: I): WorkflowConfig_EnvEntry {
    return WorkflowConfig_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowConfig_EnvEntry>, I>>(object: I): WorkflowConfig_EnvEntry {
    const message = createBaseWorkflowConfig_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCredential(): Credential {
  return { type: "", fields: {}, expiresAtMs: 0 };
}

export const Credential: MessageFns<Credential> = {
  encode(message: Credential, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      Credential_FieldsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.expiresAtMs !== 0) {
      writer.uint32(24).int64(message.expiresAtMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credential {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredential();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Credential_FieldsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.fields[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAtMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credential {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      expiresAtMs: isSet(object.expiresAtMs) ? globalThis.Number(object.expiresAtMs) : 0,
    };
  },

  toJSON(message: Credential): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = Value.toJSON(v);
        });
      }
    }
    if (message.expiresAtMs !== 0) {
      obj.expiresAtMs = Math.round(message.expiresAtMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Credential>, I>>(base?: I): Credential {
    return Credential.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Credential>, I>>(object: I): Credential {
    const message = createBaseCredential();
    message.type = object.type ?? "";
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    message.expiresAtMs = object.expiresAtMs ?? 0;
    return message;
  },
};

function createBaseCredential_FieldsEntry(): Credential_FieldsEntry {
  return { key: "", value: undefined };
}

export const Credential_FieldsEntry: MessageFns<Credential_FieldsEntry> = {
  encode(message: Credential_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credential_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredential_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credential_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Credential_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Credential_FieldsEntry>, I>>(base?: I): Credential_FieldsEntry {
    return Credential_FieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Credential_FieldsEntry>, I>>(object: I): Credential_FieldsEntry {
    const message = createBaseCredential_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseInitResponse(): InitResponse {
  return { success: false, errorCode: "", errorMessage: "", metadata: {} };
}

export const InitResponse: MessageFns<InitResponse> = {
  encode(message: InitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorCode !== "") {
      writer.uint32(18).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InitResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = InitResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InitResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitResponse>, I>>(base?: I): InitResponse {
    return InitResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitResponse>, I>>(object: I): InitResponse {
    const message = createBaseInitResponse();
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseInitResponse_MetadataEntry(): InitResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const InitResponse_MetadataEntry: MessageFns<InitResponse_MetadataEntry> = {
  encode(message: InitResponse_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitResponse_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InitResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitResponse_MetadataEntry>, I>>(base?: I): InitResponse_MetadataEntry {
    return InitResponse_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitResponse_MetadataEntry>, I>>(object: I): InitResponse_MetadataEntry {
    const message = createBaseInitResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRunRequest(): RunRequest {
  return { context: undefined, parameters: {}, parentOutput: {}, globalVars: {}, localVars: {} };
}

export const RunRequest: MessageFns<RunRequest> = {
  encode(message: RunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      RunRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.parentOutput).forEach(([key, value]) => {
      RunRequest_ParentOutputEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.globalVars).forEach(([key, value]) => {
      RunRequest_GlobalVarsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.localVars).forEach(([key, value]) => {
      RunRequest_LocalVarsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = RunRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.parameters[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = RunRequest_ParentOutputEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parentOutput[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = RunRequest_GlobalVarsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.globalVars[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = RunRequest_LocalVarsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.localVars[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest {
    return {
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      parentOutput: isObject(object.parentOutput)
        ? Object.entries(object.parentOutput).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      globalVars: isObject(object.globalVars)
        ? Object.entries(object.globalVars).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      localVars: isObject(object.localVars)
        ? Object.entries(object.localVars).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RunRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = Value.toJSON(v);
        });
      }
    }
    if (message.parentOutput) {
      const entries = Object.entries(message.parentOutput);
      if (entries.length > 0) {
        obj.parentOutput = {};
        entries.forEach(([k, v]) => {
          obj.parentOutput[k] = Value.toJSON(v);
        });
      }
    }
    if (message.globalVars) {
      const entries = Object.entries(message.globalVars);
      if (entries.length > 0) {
        obj.globalVars = {};
        entries.forEach(([k, v]) => {
          obj.globalVars[k] = Value.toJSON(v);
        });
      }
    }
    if (message.localVars) {
      const entries = Object.entries(message.localVars);
      if (entries.length > 0) {
        obj.localVars = {};
        entries.forEach(([k, v]) => {
          obj.localVars[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunRequest>, I>>(base?: I): RunRequest {
    return RunRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunRequest>, I>>(object: I): RunRequest {
    const message = createBaseRunRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.parentOutput = Object.entries(object.parentOutput ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.globalVars = Object.entries(object.globalVars ?? {}).reduce<{ [key: string]: Value }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Value.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.localVars = Object.entries(object.localVars ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRunRequest_ParametersEntry(): RunRequest_ParametersEntry {
  return { key: "", value: undefined };
}

export const RunRequest_ParametersEntry: MessageFns<RunRequest_ParametersEntry> = {
  encode(message: RunRequest_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunRequest_ParametersEntry>, I>>(base?: I): RunRequest_ParametersEntry {
    return RunRequest_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunRequest_ParametersEntry>, I>>(object: I): RunRequest_ParametersEntry {
    const message = createBaseRunRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseRunRequest_ParentOutputEntry(): RunRequest_ParentOutputEntry {
  return { key: "", value: undefined };
}

export const RunRequest_ParentOutputEntry: MessageFns<RunRequest_ParentOutputEntry> = {
  encode(message: RunRequest_ParentOutputEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest_ParentOutputEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest_ParentOutputEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest_ParentOutputEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunRequest_ParentOutputEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunRequest_ParentOutputEntry>, I>>(base?: I): RunRequest_ParentOutputEntry {
    return RunRequest_ParentOutputEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunRequest_ParentOutputEntry>, I>>(object: I): RunRequest_ParentOutputEntry {
    const message = createBaseRunRequest_ParentOutputEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseRunRequest_GlobalVarsEntry(): RunRequest_GlobalVarsEntry {
  return { key: "", value: undefined };
}

export const RunRequest_GlobalVarsEntry: MessageFns<RunRequest_GlobalVarsEntry> = {
  encode(message: RunRequest_GlobalVarsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest_GlobalVarsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest_GlobalVarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest_GlobalVarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunRequest_GlobalVarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunRequest_GlobalVarsEntry>, I>>(base?: I): RunRequest_GlobalVarsEntry {
    return RunRequest_GlobalVarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunRequest_GlobalVarsEntry>, I>>(object: I): RunRequest_GlobalVarsEntry {
    const message = createBaseRunRequest_GlobalVarsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseRunRequest_LocalVarsEntry(): RunRequest_LocalVarsEntry {
  return { key: "", value: undefined };
}

export const RunRequest_LocalVarsEntry: MessageFns<RunRequest_LocalVarsEntry> = {
  encode(message: RunRequest_LocalVarsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest_LocalVarsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest_LocalVarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest_LocalVarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: RunRequest_LocalVarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunRequest_LocalVarsEntry>, I>>(base?: I): RunRequest_LocalVarsEntry {
    return RunRequest_LocalVarsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunRequest_LocalVarsEntry>, I>>(object: I): RunRequest_LocalVarsEntry {
    const message = createBaseRunRequest_LocalVarsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseRunResponse(): RunResponse {
  return { type: 0, timestampMs: 0, log: undefined, progress: undefined, result: undefined, error: undefined };
}

export const RunResponse: MessageFns<RunResponse> = {
  encode(message: RunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.timestampMs !== 0) {
      writer.uint32(16).int64(message.timestampMs);
    }
    if (message.log !== undefined) {
      LogPayload.encode(message.log, writer.uint32(82).fork()).join();
    }
    if (message.progress !== undefined) {
      ProgressPayload.encode(message.progress, writer.uint32(90).fork()).join();
    }
    if (message.result !== undefined) {
      ResultPayload.encode(message.result, writer.uint32(98).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorPayload.encode(message.error, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestampMs = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.log = LogPayload.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.progress = ProgressPayload.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.result = ResultPayload.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.error = ErrorPayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponse {
    return {
      type: isSet(object.type) ? responseTypeFromJSON(object.type) : 0,
      timestampMs: isSet(object.timestampMs) ? globalThis.Number(object.timestampMs) : 0,
      log: isSet(object.log) ? LogPayload.fromJSON(object.log) : undefined,
      progress: isSet(object.progress) ? ProgressPayload.fromJSON(object.progress) : undefined,
      result: isSet(object.result) ? ResultPayload.fromJSON(object.result) : undefined,
      error: isSet(object.error) ? ErrorPayload.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RunResponse): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = responseTypeToJSON(message.type);
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    if (message.log !== undefined) {
      obj.log = LogPayload.toJSON(message.log);
    }
    if (message.progress !== undefined) {
      obj.progress = ProgressPayload.toJSON(message.progress);
    }
    if (message.result !== undefined) {
      obj.result = ResultPayload.toJSON(message.result);
    }
    if (message.error !== undefined) {
      obj.error = ErrorPayload.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunResponse>, I>>(base?: I): RunResponse {
    return RunResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunResponse>, I>>(object: I): RunResponse {
    const message = createBaseRunResponse();
    message.type = object.type ?? 0;
    message.timestampMs = object.timestampMs ?? 0;
    message.log = (object.log !== undefined && object.log !== null) ? LogPayload.fromPartial(object.log) : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? ProgressPayload.fromPartial(object.progress)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? ResultPayload.fromPartial(object.result)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorPayload.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseLogPayload(): LogPayload {
  return { level: 0, message: "", fields: {} };
}

export const LogPayload: MessageFns<LogPayload> = {
  encode(message: LogPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.fields).forEach(([key, value]) => {
      LogPayload_FieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = LogPayload_FieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.fields[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogPayload {
    return {
      level: isSet(object.level) ? logLevelFromJSON(object.level) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LogPayload): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = logLevelToJSON(message.level);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogPayload>, I>>(base?: I): LogPayload {
    return LogPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogPayload>, I>>(object: I): LogPayload {
    const message = createBaseLogPayload();
    message.level = object.level ?? 0;
    message.message = object.message ?? "";
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseLogPayload_FieldsEntry(): LogPayload_FieldsEntry {
  return { key: "", value: "" };
}

export const LogPayload_FieldsEntry: MessageFns<LogPayload_FieldsEntry> = {
  encode(message: LogPayload_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogPayload_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogPayload_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogPayload_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LogPayload_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogPayload_FieldsEntry>, I>>(base?: I): LogPayload_FieldsEntry {
    return LogPayload_FieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogPayload_FieldsEntry>, I>>(object: I): LogPayload_FieldsEntry {
    const message = createBaseLogPayload_FieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProgressPayload(): ProgressPayload {
  return { current: 0, total: 0, message: "", percentage: 0 };
}

export const ProgressPayload: MessageFns<ProgressPayload> = {
  encode(message: ProgressPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.current !== 0) {
      writer.uint32(8).int32(message.current);
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.percentage !== 0) {
      writer.uint32(33).double(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProgressPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgressPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.current = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.percentage = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProgressPayload {
    return {
      current: isSet(object.current) ? globalThis.Number(object.current) : 0,
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: ProgressPayload): unknown {
    const obj: any = {};
    if (message.current !== 0) {
      obj.current = Math.round(message.current);
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.percentage !== 0) {
      obj.percentage = message.percentage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProgressPayload>, I>>(base?: I): ProgressPayload {
    return ProgressPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProgressPayload>, I>>(object: I): ProgressPayload {
    const message = createBaseProgressPayload();
    message.current = object.current ?? 0;
    message.total = object.total ?? 0;
    message.message = object.message ?? "";
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBaseResultPayload(): ResultPayload {
  return { output: {}, branchIndex: 0, nextNodeId: "", status: 0, durationMs: 0 };
}

export const ResultPayload: MessageFns<ResultPayload> = {
  encode(message: ResultPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.output).forEach(([key, value]) => {
      ResultPayload_OutputEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.branchIndex !== 0) {
      writer.uint32(16).int32(message.branchIndex);
    }
    if (message.nextNodeId !== "") {
      writer.uint32(26).string(message.nextNodeId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.durationMs !== 0) {
      writer.uint32(40).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = ResultPayload_OutputEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.output[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.branchIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextNodeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.durationMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultPayload {
    return {
      output: isObject(object.output)
        ? Object.entries(object.output).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
      branchIndex: isSet(object.branchIndex) ? globalThis.Number(object.branchIndex) : 0,
      nextNodeId: isSet(object.nextNodeId) ? globalThis.String(object.nextNodeId) : "",
      status: isSet(object.status) ? executionStatusFromJSON(object.status) : 0,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
    };
  },

  toJSON(message: ResultPayload): unknown {
    const obj: any = {};
    if (message.output) {
      const entries = Object.entries(message.output);
      if (entries.length > 0) {
        obj.output = {};
        entries.forEach(([k, v]) => {
          obj.output[k] = Value.toJSON(v);
        });
      }
    }
    if (message.branchIndex !== 0) {
      obj.branchIndex = Math.round(message.branchIndex);
    }
    if (message.nextNodeId !== "") {
      obj.nextNodeId = message.nextNodeId;
    }
    if (message.status !== 0) {
      obj.status = executionStatusToJSON(message.status);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultPayload>, I>>(base?: I): ResultPayload {
    return ResultPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultPayload>, I>>(object: I): ResultPayload {
    const message = createBaseResultPayload();
    message.output = Object.entries(object.output ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    message.branchIndex = object.branchIndex ?? 0;
    message.nextNodeId = object.nextNodeId ?? "";
    message.status = object.status ?? 0;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseResultPayload_OutputEntry(): ResultPayload_OutputEntry {
  return { key: "", value: undefined };
}

export const ResultPayload_OutputEntry: MessageFns<ResultPayload_OutputEntry> = {
  encode(message: ResultPayload_OutputEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultPayload_OutputEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultPayload_OutputEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultPayload_OutputEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ResultPayload_OutputEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultPayload_OutputEntry>, I>>(base?: I): ResultPayload_OutputEntry {
    return ResultPayload_OutputEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultPayload_OutputEntry>, I>>(object: I): ResultPayload_OutputEntry {
    const message = createBaseResultPayload_OutputEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseErrorPayload(): ErrorPayload {
  return { code: "", message: "", errorType: 0, retryable: false, retryAfterMs: 0, details: {}, stackTrace: "" };
}

export const ErrorPayload: MessageFns<ErrorPayload> = {
  encode(message: ErrorPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.errorType !== 0) {
      writer.uint32(24).int32(message.errorType);
    }
    if (message.retryable !== false) {
      writer.uint32(32).bool(message.retryable);
    }
    if (message.retryAfterMs !== 0) {
      writer.uint32(40).int32(message.retryAfterMs);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      ErrorPayload_DetailsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.stackTrace !== "") {
      writer.uint32(58).string(message.stackTrace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retryable = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.retryAfterMs = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = ErrorPayload_DetailsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.details[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorPayload {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      errorType: isSet(object.errorType) ? errorTypeFromJSON(object.errorType) : 0,
      retryable: isSet(object.retryable) ? globalThis.Boolean(object.retryable) : false,
      retryAfterMs: isSet(object.retryAfterMs) ? globalThis.Number(object.retryAfterMs) : 0,
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
    };
  },

  toJSON(message: ErrorPayload): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.errorType !== 0) {
      obj.errorType = errorTypeToJSON(message.errorType);
    }
    if (message.retryable !== false) {
      obj.retryable = message.retryable;
    }
    if (message.retryAfterMs !== 0) {
      obj.retryAfterMs = Math.round(message.retryAfterMs);
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorPayload>, I>>(base?: I): ErrorPayload {
    return ErrorPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorPayload>, I>>(object: I): ErrorPayload {
    const message = createBaseErrorPayload();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.errorType = object.errorType ?? 0;
    message.retryable = object.retryable ?? false;
    message.retryAfterMs = object.retryAfterMs ?? 0;
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.stackTrace = object.stackTrace ?? "";
    return message;
  },
};

function createBaseErrorPayload_DetailsEntry(): ErrorPayload_DetailsEntry {
  return { key: "", value: "" };
}

export const ErrorPayload_DetailsEntry: MessageFns<ErrorPayload_DetailsEntry> = {
  encode(message: ErrorPayload_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorPayload_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorPayload_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorPayload_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ErrorPayload_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorPayload_DetailsEntry>, I>>(base?: I): ErrorPayload_DetailsEntry {
    return ErrorPayload_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorPayload_DetailsEntry>, I>>(object: I): ErrorPayload_DetailsEntry {
    const message = createBaseErrorPayload_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStopRequest(): StopRequest {
  return { context: undefined, reason: "", force: false };
}

export const StopRequest: MessageFns<StopRequest> = {
  encode(message: StopRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      ExecutionContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = ExecutionContext.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopRequest {
    return {
      context: isSet(object.context) ? ExecutionContext.fromJSON(object.context) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: StopRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = ExecutionContext.toJSON(message.context);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopRequest>, I>>(base?: I): StopRequest {
    return StopRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopRequest>, I>>(object: I): StopRequest {
    const message = createBaseStopRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? ExecutionContext.fromPartial(object.context)
      : undefined;
    message.reason = object.reason ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseStopResponse(): StopResponse {
  return { success: false, message: "", status: 0 };
}

export const StopResponse: MessageFns<StopResponse> = {
  encode(message: StopResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? stopStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: StopResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = stopStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopResponse>, I>>(base?: I): StopResponse {
    return StopResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopResponse>, I>>(object: I): StopResponse {
    const message = createBaseStopResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTestCredentialRequest(): TestCredentialRequest {
  return { credentialType: "", credential: undefined, timeoutMs: 0 };
}

export const TestCredentialRequest: MessageFns<TestCredentialRequest> = {
  encode(message: TestCredentialRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credentialType !== "") {
      writer.uint32(10).string(message.credentialType);
    }
    if (message.credential !== undefined) {
      Credential.encode(message.credential, writer.uint32(18).fork()).join();
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(24).int32(message.timeoutMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCredentialRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCredentialRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.credentialType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.credential = Credential.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timeoutMs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCredentialRequest {
    return {
      credentialType: isSet(object.credentialType) ? globalThis.String(object.credentialType) : "",
      credential: isSet(object.credential) ? Credential.fromJSON(object.credential) : undefined,
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
    };
  },

  toJSON(message: TestCredentialRequest): unknown {
    const obj: any = {};
    if (message.credentialType !== "") {
      obj.credentialType = message.credentialType;
    }
    if (message.credential !== undefined) {
      obj.credential = Credential.toJSON(message.credential);
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCredentialRequest>, I>>(base?: I): TestCredentialRequest {
    return TestCredentialRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCredentialRequest>, I>>(object: I): TestCredentialRequest {
    const message = createBaseTestCredentialRequest();
    message.credentialType = object.credentialType ?? "";
    message.credential = (object.credential !== undefined && object.credential !== null)
      ? Credential.fromPartial(object.credential)
      : undefined;
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseTestCredentialResponse(): TestCredentialResponse {
  return { success: false, errorCode: "", errorMessage: "", info: {} };
}

export const TestCredentialResponse: MessageFns<TestCredentialResponse> = {
  encode(message: TestCredentialResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorCode !== "") {
      writer.uint32(18).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    Object.entries(message.info).forEach(([key, value]) => {
      TestCredentialResponse_InfoEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCredentialResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCredentialResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = TestCredentialResponse_InfoEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.info[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCredentialResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      info: isObject(object.info)
        ? Object.entries(object.info).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TestCredentialResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.info) {
      const entries = Object.entries(message.info);
      if (entries.length > 0) {
        obj.info = {};
        entries.forEach(([k, v]) => {
          obj.info[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCredentialResponse>, I>>(base?: I): TestCredentialResponse {
    return TestCredentialResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCredentialResponse>, I>>(object: I): TestCredentialResponse {
    const message = createBaseTestCredentialResponse();
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.info = Object.entries(object.info ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTestCredentialResponse_InfoEntry(): TestCredentialResponse_InfoEntry {
  return { key: "", value: "" };
}

export const TestCredentialResponse_InfoEntry: MessageFns<TestCredentialResponse_InfoEntry> = {
  encode(message: TestCredentialResponse_InfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestCredentialResponse_InfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestCredentialResponse_InfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestCredentialResponse_InfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TestCredentialResponse_InfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestCredentialResponse_InfoEntry>, I>>(
    base?: I,
  ): TestCredentialResponse_InfoEntry {
    return TestCredentialResponse_InfoEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestCredentialResponse_InfoEntry>, I>>(
    object: I,
  ): TestCredentialResponse_InfoEntry {
    const message = createBaseTestCredentialResponse_InfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { includeDetails: false };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeDetails !== false) {
      writer.uint32(8).bool(message.includeDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeDetails = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { includeDetails: isSet(object.includeDetails) ? globalThis.Boolean(object.includeDetails) : false };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.includeDetails !== false) {
      obj.includeDetails = message.includeDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.includeDetails = object.includeDetails ?? false;
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return {
    status: 0,
    message: "",
    pluginVersion: "",
    protocolVersion: "",
    supportedFeatures: [],
    details: {},
    resourceUsage: undefined,
    checkedAtMs: 0,
  };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.pluginVersion !== "") {
      writer.uint32(26).string(message.pluginVersion);
    }
    if (message.protocolVersion !== "") {
      writer.uint32(34).string(message.protocolVersion);
    }
    for (const v of message.supportedFeatures) {
      writer.uint32(42).string(v!);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      HealthCheckResponse_DetailsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.resourceUsage !== undefined) {
      ResourceUsage.encode(message.resourceUsage, writer.uint32(58).fork()).join();
    }
    if (message.checkedAtMs !== 0) {
      writer.uint32(64).int64(message.checkedAtMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pluginVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.protocolVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.supportedFeatures.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = HealthCheckResponse_DetailsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.details[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.resourceUsage = ResourceUsage.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.checkedAtMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      pluginVersion: isSet(object.pluginVersion) ? globalThis.String(object.pluginVersion) : "",
      protocolVersion: isSet(object.protocolVersion) ? globalThis.String(object.protocolVersion) : "",
      supportedFeatures: globalThis.Array.isArray(object?.supportedFeatures)
        ? object.supportedFeatures.map((e: any) => globalThis.String(e))
        : [],
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: HealthCheckDetail }>((acc, [key, value]) => {
          acc[key] = HealthCheckDetail.fromJSON(value);
          return acc;
        }, {})
        : {},
      resourceUsage: isSet(object.resourceUsage) ? ResourceUsage.fromJSON(object.resourceUsage) : undefined,
      checkedAtMs: isSet(object.checkedAtMs) ? globalThis.Number(object.checkedAtMs) : 0,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.pluginVersion !== "") {
      obj.pluginVersion = message.pluginVersion;
    }
    if (message.protocolVersion !== "") {
      obj.protocolVersion = message.protocolVersion;
    }
    if (message.supportedFeatures?.length) {
      obj.supportedFeatures = message.supportedFeatures;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = HealthCheckDetail.toJSON(v);
        });
      }
    }
    if (message.resourceUsage !== undefined) {
      obj.resourceUsage = ResourceUsage.toJSON(message.resourceUsage);
    }
    if (message.checkedAtMs !== 0) {
      obj.checkedAtMs = Math.round(message.checkedAtMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.pluginVersion = object.pluginVersion ?? "";
    message.protocolVersion = object.protocolVersion ?? "";
    message.supportedFeatures = object.supportedFeatures?.map((e) => e) || [];
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: HealthCheckDetail }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = HealthCheckDetail.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.resourceUsage = (object.resourceUsage !== undefined && object.resourceUsage !== null)
      ? ResourceUsage.fromPartial(object.resourceUsage)
      : undefined;
    message.checkedAtMs = object.checkedAtMs ?? 0;
    return message;
  },
};

function createBaseHealthCheckResponse_DetailsEntry(): HealthCheckResponse_DetailsEntry {
  return { key: "", value: undefined };
}

export const HealthCheckResponse_DetailsEntry: MessageFns<HealthCheckResponse_DetailsEntry> = {
  encode(message: HealthCheckResponse_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      HealthCheckDetail.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = HealthCheckDetail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? HealthCheckDetail.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = HealthCheckDetail.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse_DetailsEntry>, I>>(
    base?: I,
  ): HealthCheckResponse_DetailsEntry {
    return HealthCheckResponse_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse_DetailsEntry>, I>>(
    object: I,
  ): HealthCheckResponse_DetailsEntry {
    const message = createBaseHealthCheckResponse_DetailsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? HealthCheckDetail.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseHealthCheckDetail(): HealthCheckDetail {
  return { status: 0, message: "", latencyMs: 0 };
}

export const HealthCheckDetail: MessageFns<HealthCheckDetail> = {
  encode(message: HealthCheckDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.latencyMs !== 0) {
      writer.uint32(24).int64(message.latencyMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.latencyMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckDetail {
    return {
      status: isSet(object.status) ? healthStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      latencyMs: isSet(object.latencyMs) ? globalThis.Number(object.latencyMs) : 0,
    };
  },

  toJSON(message: HealthCheckDetail): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.latencyMs !== 0) {
      obj.latencyMs = Math.round(message.latencyMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckDetail>, I>>(base?: I): HealthCheckDetail {
    return HealthCheckDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckDetail>, I>>(object: I): HealthCheckDetail {
    const message = createBaseHealthCheckDetail();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.latencyMs = object.latencyMs ?? 0;
    return message;
  },
};

function createBaseResourceUsage(): ResourceUsage {
  return { memoryBytes: 0, cpuPercent: 0, goroutines: 0, activeConnections: 0 };
}

export const ResourceUsage: MessageFns<ResourceUsage> = {
  encode(message: ResourceUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memoryBytes !== 0) {
      writer.uint32(8).int64(message.memoryBytes);
    }
    if (message.cpuPercent !== 0) {
      writer.uint32(17).double(message.cpuPercent);
    }
    if (message.goroutines !== 0) {
      writer.uint32(24).int32(message.goroutines);
    }
    if (message.activeConnections !== 0) {
      writer.uint32(32).int32(message.activeConnections);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.memoryBytes = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.cpuPercent = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.goroutines = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activeConnections = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceUsage {
    return {
      memoryBytes: isSet(object.memoryBytes) ? globalThis.Number(object.memoryBytes) : 0,
      cpuPercent: isSet(object.cpuPercent) ? globalThis.Number(object.cpuPercent) : 0,
      goroutines: isSet(object.goroutines) ? globalThis.Number(object.goroutines) : 0,
      activeConnections: isSet(object.activeConnections) ? globalThis.Number(object.activeConnections) : 0,
    };
  },

  toJSON(message: ResourceUsage): unknown {
    const obj: any = {};
    if (message.memoryBytes !== 0) {
      obj.memoryBytes = Math.round(message.memoryBytes);
    }
    if (message.cpuPercent !== 0) {
      obj.cpuPercent = message.cpuPercent;
    }
    if (message.goroutines !== 0) {
      obj.goroutines = Math.round(message.goroutines);
    }
    if (message.activeConnections !== 0) {
      obj.activeConnections = Math.round(message.activeConnections);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceUsage>, I>>(base?: I): ResourceUsage {
    return ResourceUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceUsage>, I>>(object: I): ResourceUsage {
    const message = createBaseResourceUsage();
    message.memoryBytes = object.memoryBytes ?? 0;
    message.cpuPercent = object.cpuPercent ?? 0;
    message.goroutines = object.goroutines ?? 0;
    message.activeConnections = object.activeConnections ?? 0;
    return message;
  },
};

/** NodePluginService 定义节点插件的 gRPC 服务接口 */
export type NodePluginServiceService = typeof NodePluginServiceService;
export const NodePluginServiceService = {
  /** GetMetadata 获取插件元数据（插件能力描述） */
  getMetadata: {
    path: "/node_plugin.NodePluginService/GetMetadata",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMetadataRequest): Buffer => Buffer.from(GetMetadataRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMetadataRequest => GetMetadataRequest.decode(value),
    responseSerialize: (value: GetMetadataResponse): Buffer => Buffer.from(GetMetadataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMetadataResponse => GetMetadataResponse.decode(value),
  },
  /** Init 初始化节点（在执行前调用） */
  init: {
    path: "/node_plugin.NodePluginService/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: InitRequest): Buffer => Buffer.from(InitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): InitRequest => InitRequest.decode(value),
    responseSerialize: (value: InitResponse): Buffer => Buffer.from(InitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): InitResponse => InitResponse.decode(value),
  },
  /** Run 执行节点（支持流式输出） */
  run: {
    path: "/node_plugin.NodePluginService/Run",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: RunRequest): Buffer => Buffer.from(RunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunRequest => RunRequest.decode(value),
    responseSerialize: (value: RunResponse): Buffer => Buffer.from(RunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunResponse => RunResponse.decode(value),
  },
  /** Stop 停止正在执行的节点（优雅停止） */
  stop: {
    path: "/node_plugin.NodePluginService/Stop",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StopRequest): Buffer => Buffer.from(StopRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StopRequest => StopRequest.decode(value),
    responseSerialize: (value: StopResponse): Buffer => Buffer.from(StopResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StopResponse => StopResponse.decode(value),
  },
  /** TestCredential 测试凭证有效性 */
  testCredential: {
    path: "/node_plugin.NodePluginService/TestCredential",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TestCredentialRequest): Buffer =>
      Buffer.from(TestCredentialRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TestCredentialRequest => TestCredentialRequest.decode(value),
    responseSerialize: (value: TestCredentialResponse): Buffer =>
      Buffer.from(TestCredentialResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TestCredentialResponse => TestCredentialResponse.decode(value),
  },
  /** HealthCheck 健康检查 */
  healthCheck: {
    path: "/node_plugin.NodePluginService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface NodePluginServiceServer extends UntypedServiceImplementation {
  /** GetMetadata 获取插件元数据（插件能力描述） */
  getMetadata: handleUnaryCall<GetMetadataRequest, GetMetadataResponse>;
  /** Init 初始化节点（在执行前调用） */
  init: handleUnaryCall<InitRequest, InitResponse>;
  /** Run 执行节点（支持流式输出） */
  run: handleServerStreamingCall<RunRequest, RunResponse>;
  /** Stop 停止正在执行的节点（优雅停止） */
  stop: handleUnaryCall<StopRequest, StopResponse>;
  /** TestCredential 测试凭证有效性 */
  testCredential: handleUnaryCall<TestCredentialRequest, TestCredentialResponse>;
  /** HealthCheck 健康检查 */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface NodePluginServiceClient extends Client {
  /** GetMetadata 获取插件元数据（插件能力描述） */
  getMetadata(
    request: GetMetadataRequest,
    callback: (error: ServiceError | null, response: GetMetadataResponse) => void,
  ): ClientUnaryCall;
  getMetadata(
    request: GetMetadataRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMetadataResponse) => void,
  ): ClientUnaryCall;
  getMetadata(
    request: GetMetadataRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMetadataResponse) => void,
  ): ClientUnaryCall;
  /** Init 初始化节点（在执行前调用） */
  init(request: InitRequest, callback: (error: ServiceError | null, response: InitResponse) => void): ClientUnaryCall;
  init(
    request: InitRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InitResponse) => void,
  ): ClientUnaryCall;
  init(
    request: InitRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InitResponse) => void,
  ): ClientUnaryCall;
  /** Run 执行节点（支持流式输出） */
  run(request: RunRequest, options?: Partial<CallOptions>): ClientReadableStream<RunResponse>;
  run(request: RunRequest, metadata?: Metadata, options?: Partial<CallOptions>): ClientReadableStream<RunResponse>;
  /** Stop 停止正在执行的节点（优雅停止） */
  stop(request: StopRequest, callback: (error: ServiceError | null, response: StopResponse) => void): ClientUnaryCall;
  stop(
    request: StopRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StopResponse) => void,
  ): ClientUnaryCall;
  stop(
    request: StopRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StopResponse) => void,
  ): ClientUnaryCall;
  /** TestCredential 测试凭证有效性 */
  testCredential(
    request: TestCredentialRequest,
    callback: (error: ServiceError | null, response: TestCredentialResponse) => void,
  ): ClientUnaryCall;
  testCredential(
    request: TestCredentialRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TestCredentialResponse) => void,
  ): ClientUnaryCall;
  testCredential(
    request: TestCredentialRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TestCredentialResponse) => void,
  ): ClientUnaryCall;
  /** HealthCheck 健康检查 */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const NodePluginServiceClient = makeGenericClientConstructor(
  NodePluginServiceService,
  "node_plugin.NodePluginService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): NodePluginServiceClient;
  service: typeof NodePluginServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
